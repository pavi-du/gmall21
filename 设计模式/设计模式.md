DTO（Data Transfer Object，据传输对象

### 1.单例模式

```java
class Singleton {
    private Singleton singleton = null;
    private Singleton(){}
    public static Singleton getInstance(){
        if(singleton==null){
            synchronized(Singleton.class){
                if(singleton==null){
                    singleton = new Singleton();
                }
            }
        }
    }
}
```

创建对象消耗资源
单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在
内存中，避免对同一个资源文件的同时写操作。

在一个系统中，要求一个类有且仅有一个对象要求生成唯一序列号的环境
创建一个对象需要消耗的资源过多



### 2.工厂方法设计模式

```java
public abstract  class Product{
	public void show(){}
}
```

```java
public class ConcreteProduct extends Product{
    public void show(){
		//concreteProduct
    }
}
```

```java
public abstract  class Creator{
	public abstract <T extends Product> T createProduct(Class<T> t);
}
```

```java
public  class ConcreteCreator{
	public <T extends Product> T createProduct(Class<T> t){
        Product product = Class.forName(t).newInstance();
        return (T)Product;
    }
}
```

#### 2.1优点

​	①封装性：不需要关心对象的创建过程
​	②扩展性：增加产品类，工厂类不需要更改
​	③屏蔽产品类：工厂类返回的抽象产品

### 3.抽象工厂模式

产品族、产品等级 有几个等级就有几个工厂   1->a1,b1    2->a2,b2



```java
public class Creator1 extends AbstractCreator {
//只生产产品等级为1的A产品
public AbstractProductA createProductA() {
	return new ProductA1();
}
//只生产产品等级为1的B产品
public AbstractProductB createProductB() {
		return new ProductB1();
}
}
```



#### 3.1优点缺点

优点：

缺点：产品族扩展困难，每一个工厂都需要增加一个方法

#### 3.2使用场景

例如一个文本编辑器和一个图片处理器，都是软件实体，但是linux下的文本编辑器和Windows下的文本编辑器虽然功能和界面都相同，但是代码实现是不同的。

### 8.模板模式

基本方法：基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。

模板方法：可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑。

抽象类中一个具体的方法完成对子类方法的调用并生成固定逻辑。

```java
public abstract class AbstractClass {
    //基本方法
    protected abstract void doSomething();
    //基本方法
    protected abstract void doAnything();
    //模板方法
    public void run(){
        /*
        * 调用基本方法，完成相关的逻辑
        */
        this.doAnything();
        this.doSomething();
    }
}
```

```java
public class ConcreteClass1 extends AbstractClass {
    //基本方法
    protected abstract void doSomething(){
        
    }
    //基本方法
    protected abstract void doAnything(){
        //....
    }
  
}
```

```java
 public class ConcreteClass1 extends AbstractClass {
    //基本方法
    protected abstract void doSomething(){
        
    }
    //基本方法
    protected abstract void doAnything(){
        //....
    }
}
```

优点：封装不变部分，扩展可变部分；提取公共部分代码，便于维护
缺点：按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成
具体的事物属性和方法,但是模板方法模式却颠倒了。

适用场景：多个子类有公有的方法，并且逻辑基本相同时

### 9代理模式

```java
public interface class Subject {
    //定义一个方法
    public void request();
}
```

```java
public class Subject implements Subject{
	public void request(){
        
    }
}
```

```java
public class Proxy implements Subject{
    private Subject proxy;
    public Proxy(Subject subject){
        this.proxy = subject;
    }
	public void request(){
        this.proxy.request();
    }
}

```

优点：职责清晰：真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理
完成一件事务，附带的结果就是编程简洁清晰。AOP

高扩展性：具体主题角色是随时都会发生变化的，只要它实现了接口，甭管它如何变化，都逃不脱
如来佛的手掌（接口），那我们的代理类完全就可以在不做任何修改的情况下使用
适用场景：对象只需要关注自己业务逻辑，非业务逻辑交给代理对象去处理。

#### 9.2动态代理

jdk代理

为啥需要实现接口：

为什么要求被代理对象必须实现一个接口？因为JDK动态代理类已经继承了Proxy这个类，所以只能通过接口来与被代理类建立联系（两个类建立起联系，一是继承的关系【jdk已经不能通过这个方式了，因为java仅支持单继承】，另一种就是实现同一个接口【JDK动态代理选这种】），所以必须要求被代理类也得实现一个接口，这样的话代理类与被代理类就能通过这个接口建立联系了。大体就是这个意思，面试我就这么回答的，也能顶得住。



Proxy.newProxyInstance()-------->getProxyClass0()------->ProxyClassFactory.apply()-------->ProxyGenerator.generateProxyClass()。

通过getProxyClass0() 创建代理类，如果缓存中有，则取出来，否则通过ProxyClassFactory的apply方法创建代理类

ProxyGenerator.generateProxyClass()：生成自己码

代理类extends proxy implements interface,方法的实现交给InvocationHandler的invoke方法 调用方法

cglib代理

利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。

调用过程：代理对象调用this.setPerson方法->调用拦截器->methodProxy.invokeSuper->CGLIB$setPerson$0->被代理对象setPerson方法  FastClass 为类的每个方法建立索引，调用时通过方法签名获取索引直接调用。

```java
public class PersonService {
    public PersonService() {
        System.out.println("PersonService构造");
    }
    //该方法不能被子类覆盖
    final public Person getPerson(String code) {
        System.out.println("PersonService:getPerson>>"+code);
        return null;
    }

    public void setPerson() {
        System.out.println("PersonService:setPerson");
    }
}
```

```java
public class CglibProxyIntercepter implements MethodInterceptor {
    @Override
    public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("执行前...");
        Object object = methodProxy.invokeSuper(sub, objects);
        System.out.println("执行后...");
        return object;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {        //代理类class文件存入本地磁盘
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "D:\\code");
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(PersonService.class);
        enhancer.setCallback(new CglibProxyIntercepter());
        PersonService proxy= (PersonService)  enhancer.create();       
        proxy.setPerson();        
        proxy.getPerson("1");     
    } 
}
```



### 10.观察者模式

```java
/**
 * 观察者
 *
 * @author pavi
 * @date 2020/9/14 1:13
 */
public class MyObserver implements Observer {

    @Override
    public void update(Observable o, Object arg) {
        System.out.println(o);
        System.out.println("被观察者发生变化"+arg);
    }
}
```

```java
/**
 * 被观察者
 *
 * @author pavi
 * @date 2020/9/14 1:13
 */
public class MyObservable extends Observable {
    
    public void test(){
        super.setChanged();
        super.notifyObservers("44");
        super.clearChanged();
    }

}
```

```java
package java.util;

/**
 * java 提供观察者接口
 * A class can implement the <code>Observer</code> interface when it
 * wants to be informed of changes in observable objects.
 *
 * @author  Chris Warth
 * @see     java.util.Observable
 * @since   JDK1.0
 */
public interface Observer {
  
    void update(Observable o, Object arg);
}
```

```java
package java.util;

/**
 * java 提供被观察者实现类
 */
public class Observable {
    private boolean changed = false;
    private Vector<Observer> obs;


    public Observable() {
        obs = new Vector<>();
    }

  
    public synchronized void addObserver(Observer o) {
        if (o == null)
            throw new NullPointerException();
        if (!obs.contains(o)) {
            obs.addElement(o);
        }
    }

   
    public synchronized void deleteObserver(Observer o) {
        obs.removeElement(o);
    }

    public void notifyObservers() {
        notifyObservers(null);
    }

    
    public void notifyObservers(Object arg) {
      
        Object[] arrLocal;

        synchronized (this) {
          
            if (!changed)
                return;
            arrLocal = obs.toArray();
            clearChanged();
        }

        for (int i = arrLocal.length-1; i>=0; i--)
            ((Observer)arrLocal[i]).update(this, arg);
    }

  
    public synchronized void deleteObservers() {
        obs.removeAllElements();
    }

    
    protected synchronized void setChanged() {
        changed = true;
    }

  
    protected synchronized void clearChanged() {
        changed = false;
    }

  
    public synchronized boolean hasChanged() {
        return changed;
    }

   
    public synchronized int countObservers() {
        return obs.size();
    }
}

```



优点：观察者和被观察者实现了解耦
缺点：如果某一观察者发生阻塞或者产生异常导致被观察者不可以进行其他操作可能影响整体的执行效率，我们可以使用多线程解决。

适用场景：事件多级触发场景

例子：

文件系统：

比如，在一个目录下新建立一个文件，这个动作会同时通知目录管理器增加该目录，并
通知磁盘管理器减少1KB的空间，也就说“文件”是一个被观察者，“目录管理器”和“磁盘管理
器”则是观察者