### 1.爬楼梯70

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。

1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。

1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/climbing-stairs
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 1.1解法

状态定义：dp[i]:到达第i层
dp[i] = dp[i-1]+dp[i-2];//它可能是从下一层、下俩层来的

```java
public class Solution {

    public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1]  = 1;
        for(int i  = 2;i<=n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}
```

### 2.买卖股票的最佳时机121

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

 

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
1.暴力法
迭代哪天买
2.一次遍历
到当前位置最小的值，然后用当前的值减去最小的差和最大利润比较

```java
public int maxProfit(int[] prices) {

        int maxprofit = 0;
        for(int i =0;i<prices.length;i++){
            for(int j=i+1;j<prices.length;j++){
                if(prices[j]-prices[i]>maxprofit){
                    maxprofit = prices[j]-prices[i];
                }
            }
        }
        return maxprofit;
    }
```

```java
public int maxProfit(int[] prices) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;

        for(int i =0;i<prices.length;i++){
            if(prices[i]<minprice){
                minprice = prices[i];
            } else if (prices[i]-minprice>maxprofit){
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;

    }
```

### 3.最大子序和53

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 3.1解法

1.动态规划：dp[i]:选择当前值，有俩种情况-》选择之前的不选择之前的
dp[i]=Math.max(dp[i-1]+nums[i],nums[i]);
res = Math.max(res,dp[i]);//dp[]中取最优的
可以使用滚动数组

```java
  public int maxSubArray(int[] nums) {

        if(nums.length == 0){
            return 0;
        }
        int res;
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        res = nums[0];
        for(int i = 1;i<nums.length;i++){
            dp[i] = Math.max(nums[i],dp[i-1]+nums[i]);
            res = Math.max(dp[i],res);
        }
        return res;
    }
```

```java
  public int maxSubArray(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        int pre = nums[0];
        int res = nums[0];
        for(int i=1;i<nums.length;i++){
            pre = Math.max(nums[i],pre+nums[i]);
            res = Math.max(pre,res);
        }
        return res;
    }
```

### 4.打家劫舍198

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/house-robber
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 4.1解法

dp[i]:到了第i间房子，可以偷也可以不偷
dp[i]=Math.max(dp[i-2]+nums[i],dp[i-1])

```java
public int rob(int[] nums) {

        int[] dp = new  int[nums.length];
        if(nums==null||nums.length == 0){
            return 0;
        }
        if(nums.length == 1){
            return nums[0];
        }
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i =2;i<nums.length;i++){
            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);
        }
        return dp[nums.length-1];
    }
```

### 5跳跃游戏55

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例 1:

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
示例 2:

输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/jump-game
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 5.1贪心算法

rightmost:可以到达最右边的位置

```java
 public boolean canJump(int[] nums) {
        int rightmost = 0;
        int n = nums.length;
        for(int i = 0;i<n;i++){
            if(i<=rightmost){
                rightmost = Math.max(rightmost,i+nums[i]);
                if(rightmost>=n-1){
                    return true;
                }
            }

        }
        return false;
    }
```

### 6.不同路径62

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

例如，上图是一个7 x 3 的网格。有多少可能的路径？

 

示例 1:

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。

1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
示例 2:

输入: m = 7, n = 3
输出: 28


提示：

1 <= m, n <= 100
题目数据保证答案小于等于 2 * 10 ^ 9

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/unique-paths
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 6.1解法

当前位置可以是从它的上边和左边来

```java
public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for(int i = 0;i<m;i++){
            dp[i][0] = 1;
        }
        for(int i = 0;i<n;i++){
            dp[0][i] = 1;
        }
        for(int i = 1;i<m;i++){
            for(int j = 1;j<n;j++){
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
```

### 7.零钱兑换322

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
示例 2:

输入: coins = [2], amount = 3
输出: -1

说明:
你可以认为每种硬币的数量是无限的。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/coin-change
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 7.1解法

dp[i]:表示金额为i的使用最小硬币数量

```java
public int coinChange(int[] coins, int amount) {

        if(amount < 1){
            return 0;
        }
        int[] dp = new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0] = 0;

        for(int i =1;i<=amount;i++){
            for(int j=0;j<coins.length;j++){
                if(coins[j]<=i){
                    dp[i] = Math.min(dp[i],dp[i-coins[j]]+1);
                }
            }
        }

        return dp[amount]==amount+1?-1:dp[amount];

    }
```

1 1  1 2 

```java
public int coinChange(int[] coins, int amount) {

        if(amount < 1){
            return 0;
        }
        return coin(coins,amount,new int[amount+1]);
    }

    private int coin(int[] coins,int amount,int[] count){
        if(amount < 0){
            return -1;
        }
        if(amount == 0){
            return 0;
        }
        if(count[amount] != 0){
            return count[amount];
        }
        int min = Integer.MAX_VALUE;

        for(int i = 0;i<coins.length;i++){

            int res = coin(coins,amount-coins[i],count);
            if(res>=0){
                min = Math.min(min,res+1);
            }

        }
        count[amount] = (min == Integer.MAX_VALUE)?-1:min;
        return count[amount];
    }
```

#### 7.3回溯法

1 2 5 5 5
1 2 2 5 5 

```java
 public int coinChange(int[] coins, int amount) {

        return coinChange(0, coins, amount);
    }

    public int coinChange(int idxCoin, int[] coins, int amount) {



        if (amount == 0) {
            return 0;
        }

        if (idxCoin < coins.length && amount > 0) {
            int maxVal = amount / coins[idxCoin];
            int minCost = Integer.MAX_VALUE;
            for (int x = 0; x <= maxVal; x++) {
                if (amount >= x * coins[idxCoin]){
                    int res = coinChange(idxCoin + 1, coins, amount - x * coins[idxCoin]);
                    if (res >=0) {
                        minCost = Math.min(minCost, res + x);
                    }

                }
            }
            return (minCost == Integer.MAX_VALUE) ? -1 : minCost;
        }
        return -1;
    }
```

### 8最长上升子序列300

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-increasing-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
 public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1);
        int res = 1;
        //important
        for(int i = 1;i<nums.length;i++){
            for(int j =0;j<i;j++){
                if(nums[i]>nums[j]){
                    dp[i] = Math.max(dp[i],dp[j]+1);
                }
            }
            res = Math.max(res,dp[i]);
        }
        return res;
    }
```

```
public int lengthOfLIS(int[] nums) {
        if(nums==null|| nums.length==0){
            return 0;
        }
        int[] d = new int[nums.length+1];
        int len = 1;
        d[1]=nums[0];
        for(int i = 1;i<nums.length;i++){
            if(nums[i]>d[len]){
                d[++len] = nums[i];
            } else {
                int l = 0;int r = len;
                int pos = 0;

                while(l<=r){
                    int mid = (l+r)/2;
                    if(d[mid]<nums[i]){
                        pos = mid;
                        l=mid+1;
                    } else {
                        r = mid-1;
                    }

                }
                d[pos+1] = nums[i];
            }
        }
        return len;
    }
```



```java
 public int lengthOfLIS(int[] nums) {

        if(nums==null||nums.length==0){
            return 0;
        }
        int[] tail = new int[nums.length];
        int end = 0;
        tail[0] = nums[0];
        for(int i = 1;i<nums.length;i++){
            if(nums[i]>tail[end]){
                tail[++end]=nums[i];
            } else {
                int l = 0;
                int r = end;
                while(l<r){
                    int mid = l+(r-l)/2;
                    if(tail[mid]<nums[i]){
                        l = mid+1;
                    } else {
                        r =  mid;
                    }
                }
                tail[l] = nums[i];
            }
        }
        return end+1;

    }
```

### 9完全平方数279

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/perfect-squares
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
 public int numSquares(int n) {
        int[] dp = new int[n+1];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0]=0;
        for(int i = 1;i<=n;i++){
            for(int j = 1;i-j*j>=0;j++){
                dp[i]=Math.min(dp[i],dp[i-j*j]+1);
            }
        }
        return dp[n];
    }
```

