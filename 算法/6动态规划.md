### 1.爬楼梯70

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。

1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/climbing-stairs
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 1.1解法

状态定义：dp[i]:到达第i层
dp[i] = dp[i-1]+dp[i-2];//它可能是从下一层、下俩层来的

```java
public class Solution {

    public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1]  = 1;
        for(int i  = 2;i<=n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}
```

### 2.买卖股票的最佳时机121

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

 

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
1.暴力法
迭代哪天买
2.一次遍历
到当前位置最小的值，然后用当前的值减去最小的差和最大利润比较

```java
public int maxProfit(int[] prices) {

        int maxprofit = 0;
        for(int i =0;i<prices.length;i++){
            for(int j=i+1;j<prices.length;j++){
                if(prices[j]-prices[i]>maxprofit){
                    maxprofit = prices[j]-prices[i];
                }
            }
        }
        return maxprofit;
    }
```

```java
public int maxProfit(int[] prices) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;

        for(int i =0;i<prices.length;i++){
            if(prices[i]<minprice){
                minprice = prices[i];
            } else if (prices[i]-minprice>maxprofit){
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;

    }
```

### 3.最大子序和53

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 3.1解法

1.动态规划：dp[i]:选择当前值，有俩种情况-》选择之前的不选择之前的
dp[i]=Math.max(dp[i-1]+nums[i],nums[i]);
res = Math.max(res,dp[i]);//dp[]中取最优的
可以使用滚动数组

```java
  public int maxSubArray(int[] nums) {

        if(nums.length == 0){
            return 0;
        }
        int res;
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        res = nums[0];
        for(int i = 1;i<nums.length;i++){
            dp[i] = Math.max(nums[i],dp[i-1]+nums[i]);
            res = Math.max(dp[i],res);
        }
        return res;
    }
```

```java
  public int maxSubArray(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        int pre = nums[0];
        int res = nums[0];
        for(int i=1;i<nums.length;i++){
            pre = Math.max(nums[i],pre+nums[i]);
            res = Math.max(pre,res);
        }
        return res;
    }
```

