### 1.删除链表中的节点237

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

示例 1：

输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2：

输入：head = [4,5,1,9], node = 1
输出：[4,5,9]
解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.


提示：

链表至少包含两个节点。
链表中所有节点的值都是唯一的。
给定的节点为非末尾节点并且一定是链表中的一个有效节点。
不要从你的函数中返回任何结果。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 1.1解法

①删除当前节点转换为删除当前节点的next节点，只需要将当前节点的next节点属性赋值给当前节点就可以了。

```java
public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
 }
```

### 2.删除链表的倒数第N个节点19

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
说明：

给定的 n 保证是有效的。

进阶：

你能尝试使用一趟扫描实现吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 2.1解法

①巧妙的使用哑节点dummy,计算出链表的长度，遍历链表删除len-n个节点即可
②n+1   len-(n+1) = 倒数第n+1个节点，即删除节点的前一个节点

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        int len = 0;
        ListNode first = dummy.next;
        while(first != null){
            len++;
            first = first.next;
        }
        len = len -n;
        first = dummy;
        while(len > 0){
            len --;
            first = first.next;
        }
        first.next = first.next.next;
        return dummy.next;
    }
```

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode f = dummy;
        ListNode s = dummy;

        for(int i = 1;i<=n+1;i++){
            f = f.next;
        }

        while( f!=null){
            f = f.next;
            s = s.next;
        }
        s.next = s.next.next;
        return dummy.next;
    }
```

### 3反转链表206

反转一个单链表。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-linked-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 3.1解法

①迭代当前链表，当前节点的next节点指向当前节点
②增加一个dummy节点，迭代链表，每个节点都有dummy 和 dummy,next中间
③递归，每次反转curr.next

```java
 public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode next = null;

        while(cur!=null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
```

```java
public ListNode reverseList(ListNode head) {
        ListNode dummy = new ListNode(0);

        ListNode cur = head;
        ListNode next;
        while(cur != null){
            next = cur.next;

            cur.next = dummy.next;
            dummy.next = cur;
            cur = next;
        }
        return dummy.next;
    }
```



```java
 public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }
        ListNode p = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return p;
    }
```

### 4合并两个有序链表21

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/merge-two-sorted-lists
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 4.1解法

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {

        if(l1 == null){
            return l2;
        }
        if(l2 == null){
            return l1;
        }

        ListNode res = new ListNode(-1);

        ListNode head = res;
        while(l1!=null && l2!=null){
            if(l1.val <= l2.val){
                res.next = l1;
                l1 = l1.next;
            }else {
                res.next = l2;
                l2 = l2.next;
            }
            res = res.next;
        }
        if( l1 !=null){
            res.next = l1;
        }
        if( l2 !=null){
            res.next = l2;
        }
        //res.next = (l1==null?l1:l2);
        return head.next;

    }
```

### 5.回文链表234

请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/palindrome-linked-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 5.1解法

```java
 public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null){
            return true;
        }

        List<ListNode> list = new ArrayList<>();
        ListNode temp = new ListNode(-1);
        temp = head;
        while(temp != null){
            list.add(temp);
            temp = temp.next;
        }
        temp = new ListNode(-1);
        temp.next = head;
        int len = list.size();
        for(int i = 0;i<len;i++){
            temp = temp.next;
            if(i<len/2){
                continue;
            }
            if(list.get(len-i-1).val != temp.val){
                return false;
            }

        }
        return true;
    }
```

```java
 ListNode frontNode;

    public boolean recursivelyCheck(ListNode currNode){
        if(currNode!=null){
            if(!recursivelyCheck(currNode.next)){
                return false;
            }
            if(frontNode.val != currNode.val){
                return false;
            }
            frontNode = frontNode.next;
        }
        return true;
    }

    public boolean isPalindrome(ListNode head) {
        frontNode = head;
        return recursivelyCheck(head);
    }
```

```java
 public boolean isPalindrome(ListNode head) {

        if(head == null || head.next == null){
            return true;
        }
        ListNode firstHalfEnd = endOfFirstHalf(head);
        ListNode secondHalfStart = firstHalfEnd.next;

        secondHalfStart = reverseListNode(secondHalfStart);

        ListNode p1 = head;
        ListNode p2 = secondHalfStart;
        boolean flag = true;
        while(p2!=null){
            if(p1.val != p2.val){
                flag = false;
                break;
            }
            p1 = p1.next;
            p2 = p2.next;
        }
        secondHalfStart = reverseListNode(secondHalfStart);
        firstHalfEnd.next = secondHalfStart;
        return flag;


    }

    public ListNode reverseListNode(ListNode curr){
        ListNode pre = null;
        ListNode next = null;
        while(curr!=null){
            next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }
        return pre;
      
    }

    public ListNode endOfFirstHalf(ListNode head){
        ListNode slow = head;
        ListNode fast = head.next;
        while(fast.next!=null&&fast.next.next!=null){
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
```

