## 字符串

### 1反转字符串344

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：

输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：

输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]

作者：力扣 (LeetCode)
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhbqj/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#### 1.1解法

第一个和最后一个进行交换，第二个和倒数第二个进行交换....

```java
public class Solution {

    public void reverseString(char[] s) {

        int len = s.length;
        for(int i = 0;i<len/2;i++){
            char tmp = s[i];
            s[i] = s[len-1-i];
            s[len-1-i] = tmp;
        }

    }
}
```

#### 1.2递归

每次调用自己的方法。

### 2整数反转7

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321
 示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-integer
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 2.1解法

每次将个位数取出来，然后判断是否会越界，如安全则加入否则退出，然后对X/10；

```java
public class Solution {

    public int reverse(int x) {

        int rev = 0;
        int top;
        while(x!=0){
            top = x % 10;
            x = x/ 10;
            if(rev> Integer.MAX_VALUE/10 || (rev==Integer.MAX_VALUE/10&&top>Integer.MAX_VALUE%10)){
                rev = 0;
                break;
            }
            if(rev<Integer.MIN_VALUE/10||(rev==Integer.MIN_VALUE/10&&top<Integer.MIN_VALUE%10)){
                rev = 0;
                break;
            }
            rev = rev*10 +top;
        }
        return rev;
    }
}

```

#### 2.2int最大值最小值

Integer.MAX_VALUE:0x7fffffff,0111+28个1    2^31-1

Integer.MIN_VALUE:0x80000000，1000+28个0   -2^31

### 3 字符串中的第一个唯一字符387

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

 

示例：

s = "leetcode"
返回 0

s = "loveleetcode"
返回 2


提示：你可以假定该字符串只包含小写字母。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 3.1解法

使用HashMap统计各个字符出现的个数，然后迭代数组，返回一个个数为1的字符在数组中的索引。

```java
public class Solution {

    public int firstUniqChar(String s) {

        Map<Character,Integer> map = new HashMap<>();
        for(int i = 0;i<s.length();i++){
            if(map.containsKey(s.charAt(i))){
                
                map.put(s.charAt(i),map.get(s.charAt(i))+1);

            } else {
                map.put(ns.charAt(i),1);
            }
        }

        for(int i = 0;i<s.length();i++){
            if(map.get(s.charAt(i))==1){
                return i;
            }
        }
        return -1;
    }
}
```

### 4.有效的字母异位词242

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false
说明:
你可以假设字符串只包含小写字母。

进阶:
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-anagram
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 4.1解法

①将俩个输入的字符串转为字符数组，然后进行排序，比较即可
②创建一个数组，迭代一个数组用于计数，迭代第二个数组，相同减一

```java
public  boolean isAnagram(String s, String t) {
        char[]  = s.toCharArray();
        char[] tarr = t.toCharArray();

        Arrays.sort(sarr);
        Arrays.sort(tarr);

        return sarr.equals(tarr);
    }
```

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    int[] table = new int[26];
    for (int i = 0; i < s.length(); i++) {
        table[s.charAt(i) - 'a']++;
    }
    for (int i = 0; i < t.length(); i++) {
        table[t.charAt(i) - 'a']--;
        if (table[t.charAt(i) - 'a'] < 0) {
            return false;
        }
    }
    return true;
}


```



### 5.验证回文串125

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:

输入: "A man, a plan, a canal: Panama"
输出: true
示例 2:

输入: "race a car"
输出: false

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-palindrome
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 5.1解法

使用双指针法，遇到非字母和数字跳过，然后比较左指针和右指针指向的字符。

```java
public class Solution {

    public boolean isPalindrome(String s) {

        int len = s.length();
        int l = 0;
        int r = len-1;

        while(l<r){
            while(l<r&&!Character.isLetterOrDigit(s.charAt(l))){
                l++;
            }
            while(l<r&&!Character.isLetterOrDigit(s.charAt(r))){
                r--;
            }
            if(l<r){
                if(Character.toLowerCase(s.charAt(l))!=Character.toLowerCase(s.charAt(r))){
                    return false;
                }
                l++;
                r--;
            }
        }
        return true;
    }
}
```

