## 数组

### 1.删除排序数组中的重复项26

给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 1.1题解

​		使用快慢指针，如果快指针指向的数和慢指针指向的数不等，则慢指针后移并将快指针指向的数赋值给慢指针。相当于给数据向前移动。如果相等只有快指针后移。

```java
public class Solution {

    public int removeDuplicates(int[] nums) {

        int i =0;
        for(int j = 1;j<nums.length;j++){
            if(nums[i]!=nums[j]){
                i++;
                nums[i] = nums[j];
            }
        }
        return i+1;
    }
}
```

### 2买卖股票的最佳时机 II 122

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 
 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 2.1题解

①暴力解决

​	每天都有三种状态，不买不卖、卖、买。把所有的状态都迭代一遍，选择最优的。

```java
public class Solution {
    int res = 0;
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if(len < 2){
            return 0;
        }
        dfs(prices,len,0,0,0);
        return this.res;
    }

    public void dfs(int[] prices,int len,int status,int index,int profit){
        if(len == index){
            this.res = Math.max(res,profit);
            return;
        }
        dfs(prices,len,status,index+1,profit);
        if(status == 0){
            dfs(prices,len,1,index+1,profit-prices[index]);
        } else {
            dfs(prices,len,0,index+1,profit+prices[index]);
        }
    }

}
```

②贪心法

每次选择当前状态最好,只要比前一天价格高就可以卖出，当然也不是必须迈出，比如连续几天增，我们可以在增的最后一天进行售卖。

```java
public class Solution {

    public int maxProfit(int[] prices) {

        if(prices.length<2){
            return 0;
        }
        int res = 0;
        for(int i = 1;i<prices.length;i++){
            if(prices[i]>prices[i-1]){
                res += (prices[i]-prices[i-1]);
            }
        }
        return res;
    }
}
```

③动态规划

n天可以设置位n个阶段，每天有买进、卖出和不做处理三个状态，其中不做处理可以不设置状态、因为它不会改变利润。可以考虑设置滚动数组进行优化。

```java
public class Solution2 {

    public int maxProfit(int[] prices) {

        int len = prices.length;
        if(len<2){
            return 0;
        }
        int[][] dp = new int[len][2];
        dp[0][0] = 0;
        dp[0][1] = -price[0];
        for(int i = 1;i<len;i++){
              dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
              dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
            //z = Math.max(pz,po+prices[i]);
            //o = Math.max(po,pz-prices[i]);
            //pz = z;
            //po = o;
        }
        return dp[len-1][0];
    }
}
```

### 3.旋转数组

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
说明:

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/rotate-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 3.1解法

①pre和pre+k的位置进行交换，更新pre,继续知道回到i,**int i =0;count<nums.length;i++**,边界条件设置比较好
②整体反转、前k个元素进行反转、剩下的元素进行反转

```java
public void rotate(int[] nums, int k) {

    int count = 0;
    int pre = 0;
    int next;
    int temp;
    int prev;
    for(int i =0;count<nums.length;i++){
        pre = i;
        prev = nums[pre];
        do{
            next = (pre+k)%nums.length;
            temp = nums[next];
            nums[next] = prev;
            pre = next;
            prev = temp;
            count++;
        }while(pre != i);
    }
}
```

```java
public void rotate(int[] nums, int k) {

        k %= nums.length;

        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
    }
    public void reverse(int[] nums,int start,int end){
        int temp = 0;
        while(start<end){
            temp = nums[start];
            nums[start] = nums[end];
            nums[end]=temp;
            start++;
            end--;
        }
    }
```

### 4存在重复元素217

给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

 

示例 1:

输入: [1,2,3,1]
输出: true
示例 2:

输入: [1,2,3,4]
输出: false
示例 3:

输入: [1,1,1,3,3,4,3,2,4,2]
输出: true

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/contains-duplicate
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 4.1解法

①排序
②判断加入

```java
public boolean containsDuplicate(int[] nums) {
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 1; ++i) {
        if (nums[i] == nums[i + 1]) return true;
    }
    return false;
}
```

```java
public boolean containsDuplicate(int[] nums) {
        Map<Integer,Integer> table = new HashMap<>();
        for(int num:nums){
            if(table.containsKey(num)){
                return true;
            } else {
                table.put(num,1);
            }
        }
        return false;
 }
```

### 5.只出现一次的数字136

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/single-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 5.1解法

①俩次迭代数组，第一次迭代首先判断标志是否不为0，否则值作为标志，第二次迭代和第一次迭代的值进行比较如果相等则temp=0;

②以后操作，相等的数异或0

```java
public int singleNumber(int[] nums) {

        int temp = 0;
        for(int i = 0;i<nums.length;i++){
            if(temp != 0){
                return temp;
            }
            temp = nums[i];
            for(int j = 0;j<nums.length;j++){
                if(i==j){
                    continue;
                }
                if(nums[i]==nums[j]){
                    temp = 0;
                }
            }

        }
        return temp;
    }
```

```java
public int singleNumber(int[] nums) {

        int res = 0;

        for(int num:nums){
            res ^= num;
        }
        return res;
  }
```

### 6.两个数组的交集 II350

给定两个数组，编写一个函数来计算它们的交集。

 

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
示例 2:

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]


说明：

输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
我们可以不考虑输出结果的顺序。
进阶：

如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小很多，哪种方法更优？
如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 6.1解法

①双指针，如果俩个数相等则加入目标数组，移动俩个指针，否则指向小的数移动指针。

②迭代个数小的数组计数，然后迭代另一个数组判断是否有相等的值且个数足够那么加入结果数组并减一。

```java
 public int[] intersect(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);

        int i = 0;
        int j = 0;
        int[] res = new int[Math.min(nums1.length,nums2.length)];
        int index = 0;
        while(i<nums1.length && j<nums2.length){
            if(nums1[i] == nums2[j]){
                res[index++] = nums1[i];
                i++;
                j++;
            }
            else if(nums1[i]<nums2[j]){
                i++;
            }
            else {
                j++;
            }
        }
        return Arrays.copyOfRange(res,0,index);
    }
```

```java
public int[] intersect(int[] nums1, int[] nums2) {
        if(nums1.length>nums2.length){
            intersect(nums2,nums1);
        }
        Map<Integer,Integer> map = new HashMap<>();
        for(int num : nums1){
            int count = map.getOrDefault(num,0)+1;
            map.put(num,count);
        }
        int[] res = new int[nums1.length+1];
        int index = 0;
        for(int num : nums2){
            int count = map.getOrDefault(num,0);
            if(count > 0){
                res[index++] = num;
            }
            map.put(num,count-1);
        }
        return Arrays.copyOfRange(res,0,index);

    }
```



### 7加一66

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:

输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
示例 2:

输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/plus-one
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 7.1解法

①从右往左迭代数组，加一取模赋值判断是否为0

```java
public int[] plusOne(int[] digits) {

        for(int i = digits.length-1;i>=0;i--){
            digits[i] += 1;
            digits[i] %= 10;
            if(digits[i]!=0){
                return digits;
            }
        }
        digits = new int[digits.length+1];
        digits[0] =1;
        return digits;
    }
```

### 8移动零283

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/move-zeroes
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 8.1解法

①迭代数组，遇到0则和后面第一个不为0的数进行交换
②后面不为0则和前面进行交换

```java
public void moveZeroes(int[] nums) {
        int len = nums.length;
        for(int i = 0;i<len;i++){
            if(nums[i]!=0){
                continue;
            }
            for(int j = i+1;j<len;j++){
                if(nums[j]==0){
                    continue;
                } else{
                    int temp = nums[i];
                    nums[i] = nums[j];
                    nums[j]=temp;
                    break;
                }
            }
        }
    }
```

```java
public void moveZeroes(int[] nums) {

        if(nums == null){
            return;
        }
        int len = nums.length;
        int j = 0;
        for(int i = 0;i<len;i++){
            if(nums[i]!=0){
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j++] = temp;
            }
        }
    }
```

### 9两数之和1

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 9.1解法

①暴力法:迭代俩次

```java
public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
      
    }
```

②俩遍hash：第一次迭代将所有数加入List中，第二次迭代看是否有目标数且索引不同

```java
public int[] twoSum(int[] nums, int target) {

        ArrayList<Integer> arr = new ArrayList<>();
        for(int i =0;i<nums.length;i++){
            arr.add(nums[i]);
        }

        for(int i =0;i<nums.length;i++){
            if(arr.contains(target-nums[i])&&arr.indexOf(target-nums[i])!=i){
               return new int[]{i,arr.indexOf(target-nums[i])}
      
            }

        }
        return new int[]{-1,-1};

    }
```

③一遍hash：先判断后加入hash

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
    }
}

```



### 10有效的数独36

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-sudoku
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 '.' 表示。

示例 1:

输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
示例 2:

输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
说明:

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
给定数独序列只包含数字 1-9 和字符 '.' 。
给定数独永远是 9x9 形式的。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-sudoku
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 10.1解法

每一行创建每一列每一个盒子分别对应一个Map,注意：**(i/3)*3+j/3**

```java
 public boolean isValidSudoku(char[][] board) {
        Map<Integer,Integer>[] r = new HashMap[9];
        Map<Integer,Integer>[] c = new HashMap[9];
        Map<Integer,Integer>[] b = new HashMap[9];

        for(int i = 0;i<9;i++){
            r[i] = new HashMap<Integer,Integer>();
            c[i] = new HashMap<Integer,Integer>();
            b[i] = new HashMap<Integer,Integer>();
        }

        for(int i = 0;i<9;i++){
            for(int j = 0;j<9;j++){
                if(board[i][j] != '.'){
                    int num =  (int)board[i][j];
                    if(r[i].get(num)!=null||c[j].get(num)!=null||b[(i/3)*3+j/3].get(num)!=null){
                        return false;
                    }
                    r[i].put(num,1);
                    c[j].put(num,1);
                    b[(i/3)*3+j/3].put(num,1);
                }
            }
        }
        return true;
    }
```

### 11旋转图像48

给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

示例 1:

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
示例 2:

给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/rotate-image
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 11.1解法

首先沿对角线顺时针旋转270°，接着一行的种线为基准顺时针旋转180°，（270+180)/360=90

```java
public void rotate(int[][] matrix) {

        int len = matrix.length;
        for(int i = 0;i<len;i++){
            for(int j =i;j<len;j++){
                int temp =  matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        for(int i =0;i<len;i++){
            for(int j=0;j<len/2;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][len-1-j];
                matrix[i][len-1-j] = temp;
            }
        }
    }
```

## 

### 12反转字符串344

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：

输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：

输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]

作者：力扣 (LeetCode)
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhbqj/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#### 1.1解法

第一个和最后一个进行交换，第二个和倒数第二个进行交换....

```java
public class Solution {

    public void reverseString(char[] s) {

        int len = s.length;
        for(int i = 0;i<len/2;i++){
            char tmp = s[i];
            s[i] = s[len-1-i];
            s[len-1-i] = tmp;
        }

    }
}
```

#### 1.2递归

每次调用自己的方法。

### 13整数反转7

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321
 示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-integer
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 2.1解法

每次将个位数取出来，然后判断是否会越界，如安全则加入否则退出，然后对X/10；

```java
public class Solution {

    public int reverse(int x) {

        int rev = 0;
        int top;
        while(x!=0){
            top = x % 10;
            x = x/ 10;
            if(rev> Integer.MAX_VALUE/10 || (rev==Integer.MAX_VALUE/10&&top>Integer.MAX_VALUE%10)){
                rev = 0;
                break;
            }
            if(rev<Integer.MIN_VALUE/10||(rev==Integer.MIN_VALUE/10&&top<Integer.MIN_VALUE%10)){
                rev = 0;
                break;
            }
            rev = rev*10 +top;
        }
        return rev;
    }
}

```

#### 2.2int最大值最小值

Integer.MAX_VALUE:0x7fffffff,0111+28个1    2^31-1

Integer.MIN_VALUE:0x80000000，1000+28个0   -2^31

### 14 字符串中的第一个唯一字符387

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

 

示例：

s = "leetcode"
返回 0

s = "loveleetcode"
返回 2


提示：你可以假定该字符串只包含小写字母。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 3.1解法

使用HashMap统计各个字符出现的个数，然后迭代数组，返回一个个数为1的字符在数组中的索引。

```java
public class Solution {

    public int firstUniqChar(String s) {

        Map<Character,Integer> map = new HashMap<>();
        for(int i = 0;i<s.length();i++){
            if(map.containsKey(s.charAt(i))){
                
                map.put(s.charAt(i),map.get(s.charAt(i))+1);

            } else {
                map.put(ns.charAt(i),1);
            }
        }

        for(int i = 0;i<s.length();i++){
            if(map.get(s.charAt(i))==1){
                return i;
            }
        }
        return -1;
    }
}
```

### 15.有效的字母异位词242

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false
说明:
你可以假设字符串只包含小写字母。

进阶:
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-anagram
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 4.1解法

①将俩个输入的字符串转为字符数组，然后进行排序，比较即可
②创建一个数组，迭代一个数组用于计数，迭代第二个数组，相同减一

```java
public  boolean isAnagram(String s, String t) {
        char[]  = s.toCharArray();
        char[] tarr = t.toCharArray();

        Arrays.sort(sarr);
        Arrays.sort(tarr);

        return sarr.equals(tarr);
    }
```

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    int[] table = new int[26];
    for (int i = 0; i < s.length(); i++) {
        table[s.charAt(i) - 'a']++;
    }
    for (int i = 0; i < t.length(); i++) {
        table[t.charAt(i) - 'a']--;
        if (table[t.charAt(i) - 'a'] < 0) {
            return false;
        }
    }
    return true;
}


```



### 16.验证回文串125

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:

输入: "A man, a plan, a canal: Panama"
输出: true
示例 2:

输入: "race a car"
输出: false

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-palindrome
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 5.1解法

使用双指针法，遇到非字母和数字跳过，然后比较左指针和右指针指向的字符。

```java
public class Solution {

    public boolean isPalindrome(String s) {

        int len = s.length();
        int l = 0;
        int r = len-1;

        while(l<r){
            while(l<r&&!Character.isLetterOrDigit(s.charAt(l))){
                l++;
            }
            while(l<r&&!Character.isLetterOrDigit(s.charAt(r))){
                r--;
            }
            if(l<r){
                if(Character.toLowerCase(s.charAt(l))!=Character.toLowerCase(s.charAt(r))){
                    return false;
                }
                l++;
                r--;
            }
        }
        return true;
    }
}
```

