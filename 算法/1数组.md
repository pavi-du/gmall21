## 数组

### 1.删除排序数组中的重复项

26.给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。



示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 1.1题解

​		使用快慢指针，如果快指针指向的数和慢指针指向的数不等，则慢指针后移并将快指针指向的数赋值给慢指针。相当于给数据向前移动。如果相等只有快指针后移。

```java
public class Solution {

    public int removeDuplicates(int[] nums) {

        int i =0;
        for(int j = 1;j<nums.length;j++){
            if(nums[i]!=nums[j]){
                i++;
                nums[i] = nums[j];
            }
        }
        return i+1;
    }
}
```

### 2买卖股票的最佳时机 II

122.给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 
 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 2.1题解

①暴力解决

​	每天都有三种状态，不买不卖、卖、买。把所有的状态都迭代一遍，选择最优的。

```java
public class Solution {
    int res = 0;
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if(len < 2){
            return 0;
        }
        dfs(prices,len,0,0,0);
        return this.res;
    }

    public void dfs(int[] prices,int len,int status,int index,int profit){
        if(len == index){
            this.res = Math.max(res,profit);
            return;
        }
        dfs(prices,len,status,index+1,profit);
        if(status == 0){
            dfs(prices,len,1,index+1,profit-prices[index]);
        } else {
            dfs(prices,len,0,index+1,profit+prices[index]);
        }
    }

}
```

②贪心法

每次选择当前状态最好,只要比前一天价格高就可以卖出，当然也不是必须迈出，比如连续几天增，我们可以在增的最后一天进行售卖。

```java
public class Solution {

    public int maxProfit(int[] prices) {

        if(prices.length<2){
            return 0;
        }
        int res = 0;
        for(int i = 1;i<prices.length;i++){
            if(prices[i]>prices[i-1]){
                res += (prices[i]-prices[i-1]);
            }
        }
        return res;
    }
}
```

③动态规划

n天可以设置位n个阶段，每天有买进、卖出和不做处理三个状态，其中不做处理可以不设置状态、因为它不会改变利润。可以考虑设置滚动数组进行优化。

```java
public class Solution2 {

    public int maxProfit(int[] prices) {

        int len = prices.length;
        if(len<2){
            return 0;
        }
        int[][] dp = new int[len][2];
        dp[0][0] = 0;
        dp[0][1] = -price[0];
        for(int i = 1;i<len;i++){
              dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
              dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
            //z = Math.max(pz,po+prices[i]);
            //o = Math.max(po,pz-prices[i]);
            //pz = z;
            //po = o;
        }
        return dp[len-1][0];
    }
}
```

