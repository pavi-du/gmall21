### 1合并两个有序数组88

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

 

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。


示例:

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/merge-sorted-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 1.1解法

①双指针，分别指向nums1,nums2中的数，迭代比较俩个指针指向的数字。

```java
 public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] res = new int[m];
        System.arraycopy(nums1,0,res,0,m);
        int r = 0;
        int p = 0;
        int q = 0;

        while(p<m&&q<n){
            nums1[r++] = res[p]<=nums2[q]?res[p++]:nums2[q++];
        }
        if(p<m){
            System.arraycopy(res,p,nums1,r,m-p);
        }
        if(q<n){
            System.arraycopy(nums2,q,nums1,r,n-q);
        }
    }
```

②先合并数组在进行排序。

```java
 public void merge(int[] nums1, int m, int[] nums2, int n) {
        System.arraycopy(nums2,0,nums1,m,n);
        Arrays.sort(nums1);
  }
```

### 2第一个错误的版本278

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

示例:

给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -> false
调用 isBadVersion(5) -> true
调用 isBadVersion(4) -> true

所以，4 是第一个错误的版本。 

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/first-bad-version
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 2.1解法

①采用二分法，防止Integer越界，所以l+(r-l)/2,  

```java
public class Solution{ 
public int firstBadVersion(int n) {

        int l = 1;
        int r = n;
        int mid ;
        while(l<r){
            // 如果是l<=r，这里会陷入死循环  
            // 如果 mid 是bad 且l==r,就是一直循环
            mid = l+(r-l)/2;
            if(isBadVersion(mid)){
                r = mid;
            } else {
                l = mid +1;
            }
        }

        return l;
    }
}

public class VersionControl {

    boolean isBadVersion(int version){
        return false;
    }
}
```

### 3,颜色分类75

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

示例:

输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
进阶：

一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/sort-colors
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 3.1解法

①双指针，p0左边全是0，p0指向1,p2右边全是2，p2指向几不确定

```java
public class Solution {

    public void sortColors(int[] nums) {
        int p0 = 0;
        int p2 = nums.length - 1;
        int curr = 0;
        while (curr <= p2) {
            if (nums[curr] == 0) {
                int tmp = nums[curr];
                nums[curr++] = nums[p0];
                nums[p0++] = tmp;
            } else if (nums[curr] == 2) {
                int tmp = nums[curr];
                nums[curr] = nums[p2];
                nums[p2--] = tmp;
            } else {
                curr++;
            }

        }
    }
}
```

### 4.前 K 个高频元素347

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

 

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]


提示：

你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
你可以按任意顺序返回答案

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/top-k-frequent-elements
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 4.1解法

①使用小顶堆

```java
 public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int num : nums){
            if(map.get(num)!=null){
                map.put(num,map.get(num)+1);
            } else {
                map.put(num,1);
            }
        }
        PriorityQueue<Integer> pq = new PriorityQueue<>(
                (o1,o2)->{
                    return map.get(o1)-map.get(o2);
                }
        );

        for(Integer key:map.keySet()){
            if(pq.size()<k){
                pq.offer(key);
            } else {
                if(map.get(pq.peek())<map.get(key)){
                    pq.poll();
                    pq.offer(key);
                }
            }
        }
        int[] res = new int[k];
        int i = 0;
        while(pq.size()!=0){
            res[i++] = pq.poll();
        }
        return res;

    }
```

### 5数组中的第K个最大元素215

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
说明:

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 5.1解法

①使用小顶堆，堆的元素k个，堆顶元素就是答案。

```java
 public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(
                (o1,o2)->{
                    return o1-o2;
                }
        );
        for(int num:nums){
            if(pq.size()<k){
                pq.offer(num);
            } else{
                if(pq.peek()<num){
                    pq.poll();
                    pq.offer(num);
                }
            }
        }
        return pq.peek();
    }
```

### 6.寻找峰值162

峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞。

示例 1:

输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。
示例 2:

输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
说明:

你的解法应该是 O(logN) 时间复杂度的。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-peak-element
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 6.1解法

①二分法，在一个峰波中跨越X最小的峰波

```java
 public int findPeakElement(int[] nums) {

        int l = 0;
        int r = nums.length-1;
        int mid  = 0;
        while(l<r){
            mid = (l+r)/2;
            if(nums[mid]>nums[mid+1]){
                r = mid;
            } else {
                l = mid+1;
            }
        }
        return l;

    }
```

②假设它是递增的，假如有一个值大于右边的则输出它

```java
 public int findPeakElement(int[] nums) {


        for(int i  = 0;i<nums.length-1;i++){
            if(nums[i]>nums[i+1]){
                return i;
            }
        }
        return nums.length-1;
    }
```

#### 6.2二分法

二分法边界值取不取=如何判断，把值代入看是否产生死循环

### 7.在排序数组中查找元素的第一个和最后一个位置34

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。

示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 7.1解法

①总体采用二分法，找到一个mid等于目标值，然后向左迭代向右迭代

```java
public int[] searchRange(int[] nums, int target) {
        int l = 0;
        int r = nums.length-1;
        int mid = 0;
        int[] ans = new int[2];
        while(l<=r){
            mid = (l+r)/2;
            if(nums[mid]<target){
                l=mid+1;
            } else if(nums[mid]>target){
                r = mid-1;
            } else {
                int i = mid;
                int j = mid;
                while(i>=0&&nums[i]==target){
                    i--;
                }
                while(j<nums.length&&nums[j]==target){
                    j++;
                }
                ans[0] = i+1;
                ans[1] = j-1;
                return ans;
            }
        }
        ans[0] = -1;
        ans[1] = -1;
        return ans;
    }
```

