### 1.二叉树最大的深度104


给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。



```
public class BFSDemo {

    public int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        int size = q.size();
        TreeNode temp = null;
        int level = 0;
        while(!q.isEmpty()){
            size = q.size();
            while(size>0){
                temp = q.poll();
                if(temp.left != null){
                    q.offer(temp.left);
                }
                if(temp.right != null){
                    q.offer(temp.right);
                }
                size--;
            }
            level++;
        }
        return level;
    }
}
```



```
public class DFSDemo {

    public int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left,right) + 1;
    }
}
```



```
public class Solution1 {

    int max = 0;
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }

        dfs(root,1);
        return max;
    }
    public void dfs(TreeNode node, int level){
        if(node.left == null && node.right == null&&level>max){
            max = level;
        }
        if(node.left != null){
            dfs(node.left,level+1);
        }
        if(node.right != null){
            dfs(node.right,level+1);
        }
    }


}
```



### 2.验证二叉搜索树98

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/validate-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



```
public class Solution {
    TreeNode pre = null;
    public boolean isValidBST(TreeNode root) {
        return help(root);
    }

    public boolean help(TreeNode node){
        if(node == null){
            return true;
        }
        if(!this.help(node.left)){
            return false;
        }
        if(pre != null && pre.val>=node.val){
            return false;
        }
        pre = new TreeNode(node.val);
        return this.help(node.right);

    }
}
```



```
public class Solution2 {
    long pre = Integer.MIN_VALUE-1;

    @Test
    public void test(){
        TreeNode node = new TreeNode(2);
        node.left = new TreeNode(1);
        node.right = new TreeNode(3);

        System.out.println(Integer.MIN_VALUE);
    }

    public boolean isValidBST(TreeNode root) {
        return inOrder(root);
    }

    public boolean inOrder(TreeNode root){
        if(root == null){
            return true;
        }
        if(!inOrder(root.left)){
            return false;
        }
        if(root.val <= pre){
            return false;
        }
        pre = root.val;
        return inOrder(root.right);
    }

}
```





```
public class Solution3 {

    public boolean isValidBST(TreeNode root) {
        return help(root,null,null);
    }

    public boolean help(TreeNode node,Integer min,Integer max){
        if(node == null){
            return true;
        }
        int val = node.val;
        if(min != null && val <= min){
            return false;
        }
        if(max != null && val >= max){
            return false;
        }
        if(!help(node.left,min,val)){
            return false;
        }
        if(!help(node.right,val,max)){
            return false;
        }
        return true;

    }
}
```





```
public class Solution4 {

    public boolean helper(TreeNode root, Integer lowwer, Integer upper){

        if(root == null){
            return true;
        }

        if(lowwer != null && (root.val <= lowwer)){
            return false;
        }
        if(upper != null && (root.val >= upper)){
            return false;
        }
        if(!helper(root.left,lowwer,root.val)){
            return false;
        }
        if(!helper(root.right,root.val,upper)){
            return false;
        }
        return true;
    }

    public boolean isValidBST(TreeNode root) {
        return helper(root,null,null);
    }
}

```



```
public class Solution5 {

    public boolean isValidBST(TreeNode root) {
        long min = Long.MIN_VALUE;
        Stack<TreeNode> s = new Stack<>();

        while(!s.isEmpty()||root!=null){
            while(root != null){
                s.push(root);
                root = root.left;
            }
            root = s.pop();
            if(root.val<=min){
                return false;
            }
            min = root.val;
            root = root.right;
        }
        return true;
    }
}

```



### 3.对称二叉树101

给定一个二叉树，检查它是否是镜像对称的。

 

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3


但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3


进阶：

你可以运用递归和迭代两种方法解决这个问题吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/symmetric-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



```
public class Solution {

    public boolean isSymmetric(TreeNode root) {
        return helper(root,root);
    }
    public boolean helper(TreeNode p,TreeNode q){

        if(p == null && q== null){
            return true;
        }
        if(p==null || q== null){
            return false;
        }
        return p.val == q.val && helper(p.left,q.right) && helper(p.right,q.left);
    }
}
```



```
public class Solution1 {

    public boolean isSymmetric(TreeNode root) {

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode p = queue.poll();
            TreeNode q = queue.poll();
            if(p== null && q == null){
                continue;
            }
            if(p==null||q==null||p.val!=q.val){
                return false;
            }
            queue.offer(p.left);
            queue.offer(q.right);
            queue.offer(p.right);
            queue.offer(q.left);
        }
        return true;
    }
}
```



```
public class Temp {

    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 访问左子树
        if (!isValidBST(root.left)) {
            return false;
        }
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if (root.val <= pre) {
            return false;
        }
        pre = root.val;
        // 访问右子树
        return isValidBST(root.right);
    }


}
```





```
public class Temp1 {

    @Test
    public void test(){
        TreeNode r = new TreeNode(1);
        r.left = new TreeNode(1);
        System.out.println(isValidBST(r));
    }

    public boolean isValidBST(TreeNode root) {
        return inOrder(root,Long.MIN_VALUE);
    }

    public boolean inOrder(TreeNode root,long pre){
        if(root == null){
            return true;
        }
        if(!inOrder(root.left,pre)){
            return false;
        }
        if(root.val <= pre){
            return false;
        }
        pre = root.val;
        return inOrder(root.right,pre);
    }
}

```



### 4.二叉树的层序遍历102

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 

示例：
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```
public class Solution1 {

    public List<List<Integer>> levelOrder(TreeNode root) {

        List<List<Integer>> res = new ArrayList<>();
        if(root != null){
            dfs(res,root,0);
        }
        return res;
    }

    public void dfs(List<List<Integer>> res, TreeNode node, int level){

        if(res.size()-1<level){
            res.add(new ArrayList<Integer>());
        }
        res.get(level).add(node.val);
        if(node.left != null){
            dfs(res,node.left,level+1);
        }
        if(node.right != null){
            dfs(res,node.right,level+1);
        }

    }
}
```



```
public class Solution2 {

    public List<List<Integer>> levelOrder(TreeNode root) {

        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null){
            return res;
        }
        queue.offer(root);
        int size;
        while(!queue.isEmpty()){
            size = queue.size();
            List<Integer> temp = new ArrayList<>();
            while(size>0){
                TreeNode node = queue.poll();
                temp.add(node.val);
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                size--;
            }
            res.add(temp);
        }
        return res;
    }
}

```



```
public class Solution3 {

    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root != null){
            dfs(res,root,0);
        }
        return res;
    }

    public void dfs(List<List<Integer>> list,TreeNode root,int level){
        if(list.size()-1<level){
            list.add(new ArrayList<Integer>());
        }
        list.get(level).add(root.val);
        if(root.left != null){
            dfs(list,root.left,level+1);
        }
        if(root.right != null){
            dfs(list,root.right,level+1);
        }
    }
}
```



### 5.将有序数组转换为二叉搜索树108

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



```java
public class Solution {

    public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums,0,nums.length-1);
    }

    public TreeNode helper(int[] nums,int l,int r) {
        if(l > r) {
            return null;
        }
        int mid = (l+r)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums,l,mid-1);
        root.right = helper(nums,mid+1,r);
        return root;
    }
}
```



### 6二叉树的中序遍历94

给定一个二叉树，返回它的中序 遍历。

示例:

输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



```java
public class Solution {

    public List<Integer> inorderTraversal(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        List<Integer> list = new ArrayList<>();
        while(!stack.isEmpty()||root!=null){
            while(root != null){
                stack.push(root);
                root = root.left;
            }

            if(stack.size()>0){
                root = stack.pop();
                list.add(root.val);
                root = root.right;
            }

        }
        return list;
    }
}

```



```java
public class Solution1 {

    List<Integer> list = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root == null){
            return list;
        }
        if(root.left !=null){
            inorderTraversal(root.left);
        }
        list.add(root.val);
        return inorderTraversal(root.right);
    }
}

```



### 7.二叉树的锯齿形层次遍历103

给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层次遍历如下：

[
  [3],
  [20,9],
  [15,7]
]
通过次数71,266提交次数129,566

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



```
public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        int index = 1;
        Queue<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> list  = new ArrayList<>();
        if(root == null){
            return list;
        }
        queue.offer(root);
        while(!queue.isEmpty()){
            while(list.size()-index < 0){
                list.add(new LinkedList<Integer>());
            }
            int size = queue.size();
            while(size>0){
                TreeNode temp = queue.poll();

                if(index % 2 == 0 ){
                    ((LinkedList<Integer>)list.get(index-1)).offerFirst(temp.val);
                } else {
                    ((LinkedList<Integer>)list.get(index-1)).offerLast(temp.val);
                }
                if(temp.left != null){
                    queue.offer(temp.left);
                }
                if(temp.right != null){
                    queue.offer(temp.right);
                }
                size--;
            }
            index++;
        }
        return list;
    }
}

```



```
public class Solution1 {

    public void dfs(List list, TreeNode root, int level){
        if(list.size()-level<0){
            list.add(new LinkedList<Integer>());
        }

        if(level % 2==0){
            ((LinkedList<Integer>)list.get(level-1)).offerFirst(root.val);
        } else {
            ((LinkedList<Integer>)list.get(level-1)).offerLast(root.val);
        }

        if(root.left != null){
            dfs(list,root.left,level+1);
        }
        if(root.right!=null){
            dfs(list,root.right,level+1);
        }
    }

    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        int index = 1;
        List<List<Integer>> list  = new ArrayList<>();
        if(root == null){
            return list;
        }
        dfs(list,root,1);
        return list;
    }
}

```



### 8从前序与中序遍历序列构造二叉树105

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
通过次数114,640提交次数168,624

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```
public class Solution {

    Map<Integer,Integer> map = new HashMap<>();

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preLeft, int preRight, int inLeft, int inRight){
        if(preLeft>preRight){
            return null;
        }
        int preorderRoot = preorder[preLeft];
        int leftSubTree = map.get(preorderRoot)-inLeft;
        //int inRootIndex = inorder[map.get(preorderRoot)];
        TreeNode root = new TreeNode(preorderRoot);
        root.left = myBuildTree(preorder,inorder,preLeft+1,leftSubTree+preLeft,inLeft,leftSubTree+inLeft-1);
        root.right = myBuildTree(preorder,inorder,leftSubTree+preLeft+1,preRight,leftSubTree+inLeft+1,inRight);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        for(int i = 0;i<n;i++){
            map.put(inorder[i],i);
        }
        return myBuildTree(preorder,inorder,0,n-1,0,n-1);
    }
}

```



```
public class Solution1 {

    public TreeNode buildTree(int[] preorder, int[] inorder) {

        if(preorder==null || preorder.length ==0){
            return null;
        }
        Stack<TreeNode> stack = new Stack<>();
        int index = 0;
        TreeNode root = new TreeNode(preorder[0]);
        stack.push(root);
        for(int i = 1;i<preorder.length;i++){
            TreeNode temp = stack.peek();
            if(temp.val != inorder[index]){
                temp.left = new TreeNode(preorder[i]);
                stack.push(temp.left);
            } else {
                while(!stack.isEmpty() && stack.peek().val == inorder[index]){
                    index++;
                    temp = stack.pop();
                }
                temp.right = new TreeNode(preorder[i]);
                stack.push(temp.right);

            }

        }
        return root;
    }
}

```



### 9.填充每个节点的下一个右侧节点指针116


给定一个**完美二叉树**，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

 

**示例：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png)

```
输入：{"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":{"$id":"6","left":null,"next":null,"right":null,"val":6},"next":null,"right":{"$id":"7","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}

输出：{"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":{"$id":"6","left":null,"next":null,"right":null,"val":7},"right":null,"val":6},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"7","left":{"$ref":"5"},"next":null,"right":{"$ref":"6"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"7"},"val":1}

解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。
```

 

**提示：**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

```
public class Solution {

    public Node connect(Node root) {

        Queue<Node> q = new LinkedList<>();
        if(root == null){
            return null;
        }
        q.offer(root);
        while(!q.isEmpty()){
            int size = q.size();
            while(size>0){
                Node temp = q.poll();
                if(size>1){
                    temp.next = q.peek();
                } else {
                    temp.next = null;
                }
                if(temp.left!=null){
                    q.offer(temp.left);
                }
                if(temp.right!=null){
                    q.offer(temp.right);
                }
                size--;
            }
        }
        return root;
    }
}

```



```
public class Solution1 {

    public Node connect(Node root) {
        if(root == null){
            return root;
        }
        Node leftmost = root;
        while(leftmost.left != null){
            Node head = leftmost;

            while(head !=null){
                head.left.next = head.right;
                if(head.next != null){
                    head.right.next = head.next.left;
                }
                head = head.next;
            }
            leftmost = leftmost.left;
        }
        return root;

    }
}

```



### 10.二叉搜索树中第K小的元素230

给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

示例 1:

输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
示例 2:

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3
进阶：
如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```
public class Solution {

    public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            while(root != null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            if(k==1){
                return root.val;
            }
            k--;

            root = root.right;

        }
        return -1;
    }
}

```



```
public class Solution1 {

    public List<Integer> inorder(TreeNode root, List<Integer> arr){
        if(root == null){
            return arr;
        }
        inorder(root.left,arr);
        arr.add(root.val);
        inorder(root.right,arr);
        return arr;
    }

    public int kthSmallest(TreeNode root, int k) {
        List<Integer> arr = inorder(root,new ArrayList<Integer>());
        return arr.get(k-1);
    }
}

```

