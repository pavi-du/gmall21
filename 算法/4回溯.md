### 1.电话号码的字母组合17

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

示例:

输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
说明:
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 1.1解法

```java
public class Solution {

    List<String> res  = new ArrayList<>();
    String[] map = new String[]{"#","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    public List<String> letterCombinations(String digits) {
        if(digits== null || digits.length() == 0){
            return res;
        }

        iterStr(digits,"",0);
        return res;
    }

    public void iterStr(String digits,String letter,int index){
        // 重要
        if(index == digits.length()){
            res.add(letter);
            return;
        }
        String str =  map[digits.charAt(index)-'0'];
        for(int i = 0;i<str.length();i++){
            iterStr(digits,letter+str.charAt(i),index+1);
        }
    }
}
```



```java
public class Solution {

    String[] map = new String[]{"#","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    public List<String> letterCombinations(String digits) {
        if(digits== null || digits.length() == 0){
            return new ArrayList<String>();
        }
        Queue<String> queue = new LinkedList<>();
        queue.offer("");
        for(int i  = 0;i<digits.length();i++){
            int size = queue.size();
            while(size>0){
                String str = queue.poll();
                String temp =  map[digits.charAt(i)-'0'];
                for(int j = 0;j<temp.length();j++){
                    queue.offer(str+temp.charAt(j));
                }
                size--;
            }
        }
        return new ArrayList<String>(queue);
    }

}
```

### 2括号生成22

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

 

示例：

输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/generate-parentheses
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 2.1解法

①暴力法

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        backtrack(res,new char[2*n],0);
        return res;

    }

    public void backtrack(List<String> res,char[] arr,int index){
        if(index == arr.length ){
            if(valid(arr))
                res.add(new String(arr));
        } else {
            arr[index] = '(';
            backtrack(res,arr,index+1);
            arr[index] = ')';
            backtrack(res,arr,index+1);
        }
       
    }

    public boolean valid(char[] arr){
        int count = 0;

        int len = arr.length;
        for(int i = 0;i<len;i++){
            if(arr[i]=='('){
                count++;
            } else{
                count--;
            }
            if(count < 0){
                return false;
            }
            
        }
        return count==0;
    }
}
```

②回溯法

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        backtrack(res,new char[2*n],0,0,0);
        return res;

    }

    public void backtrack(List<String> res,char[] arr,int index,int close,int open){
        if(index == arr.length ){
           
                res.add(new String(arr));
        } else {

            if(open<arr.length/2){
                arr[index] = '(';
                open++;
                backtrack(res,arr,index+1,close,open);
                open--;
            }

            if(close<open){
                arr[index] = ')';
                close++;
                backtrack(res,arr,index+1,close,open);
            }
               
        }
       
    }

}
```



### 3全排列46

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/permutations
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 3.1解法

①回溯：first左边是已经选择的

```java
public class Solution {

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>>  res = new ArrayList<>();
        List<Integer> output = new ArrayList<>();
        int n = nums.length;
        for(int i = 0;i<n;i++){
            output.add(nums[i]);
        }
        backtrack(n,res,output,0);
        return res;
    }

    public void backtrack(int n,List<List<Integer>> res,List<Integer> output,int first){
        if(first==n){
            res.add(new ArrayList<Integer>(output));
            return;
        }
        for(int i = first;i<n;i++){
            Collections.swap(output,first,i);
            backtrack(n,res,output,first+1);
            Collections.swap(output,first,i);
        }

    }
}

```

### 4.子集78

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
通过次数

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/subsets
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 4.1解法

①回溯：迭代长度0-n,一个数可以选可以不选，中止条件list的个数等于长度

```java
 List<List<Integer>> output = new ArrayList<>();
    int k;
    int n;

    public List<List<Integer>> subsets(int[] nums) {
        n = nums.length;
        for(k = 0;k<n+1;k++){
            ArrayList<Integer> list = new ArrayList<>();
            backtrack(0,list,nums);
        }
        return output;
    }

    public void backtrack(int first,ArrayList<Integer> list,int[] nums){
        if(k==list.size()){

            output.add(list);
            System.out.println(output);
            return;
        }
        for(int i = first;i<n;i++){
            list.add(nums[i]);
            backtrack(i+1,list,nums);
            list.remove(list.size()-1);
        }

    }
```

②递归：迭代输出的集合，加入num产生新集合，在把新的集合加入到输出的集合

```java
 public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> output = new ArrayList<>();
        output.add(new ArrayList<Integer>());

        for(int num : nums){
            List<List<Integer>> newSubsets = new ArrayList<>();
            for(List<Integer> curr : output){
                newSubsets.add(new ArrayList<Integer>(curr){{add(num);}});
            }
            for(List<Integer> curr : newSubsets){
                output.add(curr);
            }
        }
        return output;
    }
```



### 5.单词搜索79

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

示例:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false


提示：

board 和 word 中只包含大写和小写英文字母。
1 <= board.length <= 200
1 <= board[i].length <= 200
1 <= word.length <= 10^3

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/word-search
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 5.1解法

①回溯：迭代数组，试探开始的位置，若开始的字符和单词的第一个字符相同，则向四个方向试探。

```java
public class Solutioin {


    int m;
    int n;
    char[][] board;
    String  word;
    int[][] direction = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};
    boolean[][] marked;


    public boolean exist(char[][] board, String word) {
        this.board = board;
        this.word = word;

        m = board.length;
        if(m==0){
            return false;
        }
        n = board[0].length;
        marked = new boolean[m][n];
        for(int i = 0;i<m;i++){
            for(int j = 0;j<n;j++){
                if(dfs(i,j,0)){
                    return true;
                }
            }
        }
        return false;
    }

    public boolean dfs(int i,int j,int start){
        if(start == word.length()-1){
            return board[i][j] == word.charAt(start);
        }

        if(board[i][j]==word.charAt(start)){
            marked[i][j] = true;
            for(int k=0;k<4;k++){
                int newX =i+ direction[k][0];
                int newY = j+direction[k][1];
                if(isArea(newX,newY)&&!marked[newX][newY]){
                    if(dfs(newX,newY,start+1)){
                        return true;
                    }

                }
            }
            //重点
            marked[i][j] = false;
        }
        return false;
    }

    public boolean isArea(int i,int j){
        return i>=0&&i<m&&j>=0&&j<n;
    }

}
```

