## 动态规划

### 概念

*名词*

多阶段：将一个问题划分为多个阶段；
状态：每个阶段的出发点为状态；
决策：每个阶段做出的选择就是决策，
策略：各个阶段的决策变量组成的序列时策略；
最优策略：从策略中找到最优效果的策略；
状态转移方程：前一阶段的终点到后一阶段的起点；



*无后效性*

最优子结构：子问题的最优解会导致全局最优；
无后效性：某个阶段状态选择只和它的前一阶段有关。



### 题型

#### 斐波那契数列问题

##### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

难度简单1292

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

##### code

```java
class Solution {
    public int climbStairs(int n) {

        if (n <= 1) {
            return n;
        }
        int[] dp = new int[n];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < n; i++) {
            dp[i] = dp[i-1] + dp[i - 2];
        }
        return dp[n - 1];
    }
}
```

改进



```java
class Solution {
    public int climbStairs(int n) {

        if (n <= 1) {
            return n;
        }
        
        int pre2 = 1;
        int pre1 = 2;
        for (int i = 2; i < n; i++) {
            int cur = pre2 + pre1;
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
}
```

##### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

难度简单1123

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

 

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

##### code

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-2] + nums[i], dp[i - 1]);
        }
        return dp[nums.length-1];
    }
}
```

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        int[] dp = new int[nums.length];
        
        int pre2 = nums[0];
        int pre1 = Math.max(nums[0], nums[1]);
        for (int i = 2; i < nums.length; i++) {
            int cur = Math.max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
}
```

数组区间



#### 矩阵路径





#### 数组区间

##### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

难度简单200

给定一个整数数组  `nums`，求出数组从索引 `i` 到 `j`*（*`i ≤ j`）范围内元素的总和，包含 `i`、`j `两点。

实现 `NumArray` 类：

- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象
- `int sumRange(int i, int j)` 返回数组 `nums` 从索引 `i` 到 `j`*（*`i ≤ j`）范围内元素的总和，包含 `i`、`j `两点（也就是 `sum(nums[i], nums[i + 1], ... , nums[j])`）

 

**示例：**

```
输入：
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]

解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
```

 

**提示：**

- `0 <= nums.length <= 104`
- `-105 <= nums[i] <= 105`
- `0 <= i <= j < nums.length`
- 最多调用 `104` 次 `sumRange` 方法

###### code

sum[i~j] = sum[i] - sum[j - 1];

```java
class NumArray {

    private int[] sums;

    public NumArray(int[] nums) {
        if (nums != null) {
           sums = new int[nums.length + 1];
           for (int i = 1; i <= nums.length; i++) {
               sums[i] = sums[i - 1] + nums[i - 1];
           }
        }
    }
    
    public int sumRange(int i, int j) {
        return sums[j+1] - sums[i];
    }
}
```



#### 最长上升子序列

##### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

难度中等1105

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

**说明:**

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(*n2*) 。

**进阶:** 你能将算法的时间复杂度降低到 O(*n* log *n*) 吗?

###### code

```
以i结尾的序列
dp[i]:以i结尾的序列最长的长度，开始的位置可以是>=0 <i
 if(nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i],dp[j] + 1);
 }
```



```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp,1);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if(nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i],dp[j] + 1);
                }
            }
        }
        return Arrays.stream(dp).max().orElse(0);
    
    }
}
```

```

index:  arr[i-1]< key <= arr[i]
so index = i;
如果大于他所有值添加到末尾即可
```



```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int n = nums.length;
        int[] dp = new int[n];
       int len = 0;
        for (int i = 0; i < n; i++) {
            int index = binarySearch(dp,len,nums[i]);
            dp[index] = nums[i];
            if (index == len) {
                len ++;
            }
        }
        return len;
    
    }

    public int binarySearch(int[] arr, int len, int key) {
        int r = len;
        int l = 0;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (arr[mid] == key) {
                return mid;
            } else if (arr[mid] > key) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
}
```



##### [646. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)

难度中等122

给出 `n` 个数对。 在每一个数对中，第一个数字总是比第二个数字小。

现在，我们定义一种跟随关系，当且仅当 `b < c` 时，数对`(c, d)` 才可以跟在 `(a, b)` 后面。我们用这种形式来构造一个数对链。

给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

**示例 :**

```
输入: [[1,2], [2,3], [3,4]]
输出: 2
解释: 最长的数对链是 [1,2] -> [3,4]
```

**注意：**

1. 给出数对的个数在 [1, 1000] 范围内。



###### code

```
根据pairs[i][0]对pairs[][]进行排序,Arrays.sort((a,b)->a[0]-b[0])
dp[i]以pairs[i]结尾数对链的长度，开始的位置可以时》=0  <i
```







```java
class Solution {
    public int findLongestChain(int[][] pairs) {
        if (pairs == null || pairs.length == 0) {
            return 0;
        }
        Arrays.sort(pairs,(a,b) -> a[0] - b[0]);
        int n = pairs.length;
        int[] dp = new int[n];
        Arrays.fill(dp,1);
        for(int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if(pairs[j][1] < pairs[i][0]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        return Arrays.stream(dp).max().orElse(0);
    }
}
```





##### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

难度中等258

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

**示例 1:**

```
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
```

**示例 2:**

```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```

**示例 3:**

```
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```

###### code

```
这道题基本思路是遍历原数组，如果该数与前一个数的差值的正负和前一个数与它的前一个数差值相等则把该数放在前一个数的位置，否则该数添加到最后。
代码中
	up，down:目标数组中到达该数索引+1
	
前一个值是up则该前一个值的前一个值是down
前一个值是down则该前一个值的前一个值是up
```



```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if (nums== null || nums.length == 0) {
            return 0;
        }
        int up = 1;
        int down = 1;
        for(int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                up = down + 1;
            }
            if(nums[i] < nums[i - 1]) {
                down = up + 1;
            }
        }
        return Math.max(up,down);
    }
}
```

##### 最长公共子序列

​	求俩个字符串的最长公共子序列

```
dp[i][j]:str1 截取0-(i-1) str2 0-(j-1)
他们之间最长的公共子序列
dp[n1+1][n2+1]
dp[0][0]=0
if arr1[i-1]==arr[j-1]
	dp[i][j] = dp[i-1][j-1]+1
else
	dp[i][j]  = Math.max(dp[i - 1][j],dp[i][j - 1]);
```



```java
public class LengthOfLCS {

    public static void main(String[] args) {
        System.out.println(
                lengthOfLCS("addfdf".toCharArray(),"add".toCharArray())
        );
    }

    public static int lengthOfLCS(char[] arr1, char[] arr2){

        if (arr1 == null || arr2 == null) {
            return 0;
        }
        int n1 = arr1.length;
        int n2 = arr2.length;
        int[][] dp = new int[n1 + 1][n2 + 1];

        for (int i = 1; i <= n1; i++) {
            for (int j = 1; j <= n2; j++) {
                if (arr1[i-1] == arr2[j-1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
          }
        return dp[n1][n2];
    }
}

```

#### 字符串编辑

##### [583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

难度中等153

给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

 

**示例：**

```
输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

 

**提示：**

1. 给定单词的长度不超过500。
2. 给定单词中的字符只含有小写字母。

###### code

```
该题可以看作俩个字符串求最长公共字符串
```



```java
class Solution {
    public int minDistance(String word1, String word2) {
        if (word1 == null || word2 == null) {
            return 0;
        }
        int n1 = word1.length();
        int n2 = word2.length();
        int[][] dp = new int[n1 + 1][n2 + 1];
        for (int i = 1; i <= n1; i++) {
            for (int j = 1; j <= n2; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return n1 + n2 - 2 * dp[n1][n2];
    }
}
```

#### 背包问题

##### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

难度中等574

给定一个**只包含正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**注意:**

1. 每个数组中的元素不会超过 100
2. 数组的大小不会超过 200

**示例 1:**

```
输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

 

**示例 2:**

```
输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.
```



###### code



```
计算数组的和sum
w = sum /2;
boolean[] dp = new boolelan[w+1];
dp[i] = dp[i] || dp[j - num];
一个存储慢另外一个页满足了因为总和sum,
```



```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = computeArraySum(nums);
        if (sum % 2 != 0) {
            return false;
        }
       
        int W = sum / 2;
        boolean[] dp = new boolean[W+1];
        dp[0] = true;
        for (int num : nums) {
            for (int j = W; j>= num;j--){
                dp[j] = dp[j] || dp[j-num];
            }
        }
        return dp[W];
    }

    public int computeArraySum(int[] nums) {

        int sum = 0;
        for(int num : nums) {
            sum += num;
        }
        return sum;
    }
}
```

##### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

难度中等448

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-`中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

 

**示例：**

```
输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
```

 

**提示：**

- 数组非空，且长度不会超过 20 。
- 初始的数组的和不会超过 1000 。
- 保证返回的最终结果能被 32 位整数存下。

###### code

```java
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int sum = computeArraySum(nums);
        if (sum < S || (sum + S) % 2 == 1) {
            return 0;
        }
        int w = (S + sum) / 2;
        int[] dp = new int[w + 1];
        dp[0] = 1;
        for (int num : nums) {
            for (int j = w;j>=num;j--){
                dp[j] = dp[j] +dp[j-num];
            }
        }
        return dp[w];
    }

    public int computeArraySum(int[] nums) {
        int sum = 0;
        for(int num : nums) {
            sum += num;
        }
        return sum;
    }
}
```





## 搜索

### BFS

一层一层的遍历，每层遍历以上一层遍历的结果作为起点，遍历一个距离所能到达的所有节点

队列：用来存储每一轮遍历的结果；

标记：对于遍历过的节点应该做标记，防止重复遍历

一般用来解决最短路径，di<=dj

------



####  最短路径

计算网格中起点到网格中任意一点的最短路径

```
[[1,1,0,1],
[1,0,1,0],
[1,1,1,1],
[1,0,1,1]]
```

```java
public int minPathLength(int[][] grids, int tr, int tc) {
    final int[][] direction = {{0,1}, {1,0}, {0,-1}, {-1,0}};
    int m = grids.length;
    int n = grids[0].length;
    Queue<Pair<Integer,Integer>> queue = new LinkedList<>();
    int pathLenth = 0;
    queue.offer(new Pair(grids[0][0]));
    grids[0][0] =1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        pathLenth++;
        while (size-- > 0) {
            Pair<Integer,Integer> cur = queue.poll();
            int cr = cur.getKey();
            int cc = cur.getValue();
            for (int[] d : direction) {
                int nr = cr + d[0];
                int nc = cc + d[1];
                if (nr < 0 || nr >= m || nc < 0 || nc >= n || grids[nr][nc] == 0)					{
                    continue;
                }
                if (nr ==  tr && nc == tc) {
                    return pathLenth;
                }
                grids[nr][nc] = 0;
                queue.offer(new Pair<Integer>(nr,nc));
            }
        }
    }
    return -1;
    
}
```





####  [279完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/perfect-squares
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



```java
class Solution {
    public int numSquares(int n) {
       
        int level  = 0;
        boolean[] mark = new boolean[n+1];
        List<Integer> squares = generateSquares(n);
        // LinkedList:offer poll
        LinkedList<Integer> queue = new LinkedList<>();
        queue.offer(n);

        while (!queue.isEmpty()) {
            int size = queue.size();
            level++;
            while (size-- > 0) {
                int curr = queue.poll();
                for (int s : squares) {
                    int next = curr - s;
                    if(next < 0) {
                        break;
                    }
                    if(next == 0) {
                        return level;
                    }
                    // 先访问过一定比 后访问使用的路径少
                    if(mark[next]){
                        continue;
                    }
                    queue.offer(next);
                    mark[next] = true;
                }
            }
        } 
        return 0;
    }

    public List<Integer> generateSquares(int n) {
        List<Integer> squares = new ArrayList<>();
        int square = 1;
        int diff = 3;
        while (square <= n) {
            squares.add(square);
            square += diff;
            diff += 2;
        }
        return squares;
    }
}
```

#### [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

难度中等473

给定两个单词（*beginWord* 和 *endWord*）和一个字典，找到从 *beginWord* 到 *endWord* 的最短转换序列的长度。转换需遵循如下规则：

1. 每次转换只能改变一个字母。
2. 转换过程中的中间单词必须是字典中的单词。

**说明:**

- 如果不存在这样的转换序列，返回 0。
- 所有单词具有相同的长度。
- 所有单词只由小写字母组成。
- 字典中不存在重复的单词。
- 你可以假设 *beginWord* 和 *endWord* 是非空的，且二者不相同。

**示例 1:**

```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。
```

**示例 2:**

```
输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

输出: 0

解释: endWord "cog" 不在字典中，所以无法进行转换。
```

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        wordList.add(beginWord);
        int size = wordList.size();
        int start = size - 1;
        int end = 0;
        while (end < size && !endWord.equals(wordList.get(end))) {
           end++;
        }
        if(end == size) {
            return 0;
        }
        List<Integer>[] graphic = buildGraphic(wordList);
        return getShortestPath(start,end,graphic);
    }
    public List<Integer>[] buildGraphic(List<String> wordList) {
         if(wordList == null) {
            return null;
        }
        int size = wordList.size();
        List<Integer>[] graphic = new ArrayList[size];
       
        for (int i = 0; i < size; i++) {
            graphic[i] = new ArrayList<Integer>();
             for (int j = 0; j < size; j++) {
                 if(isConnect(wordList.get(i),wordList.get(j))){
                     graphic[i].add(j);
                 }
            }
        }
        return graphic;
    }


    // 判断俩个字符串是否差一个字符
    public boolean isConnect(String str1,String str2){
        int diff = 0;
        int length = str1.length();
        for (int i = 0; i < length && diff <= 1; i++) {
            if(str1.charAt(i)!=str2.charAt(i)){
                diff++;
            }
        }
        return diff == 1;
    }

    public int getShortestPath(int start,int end,List<Integer>[] graphic) {
        LinkedList<Integer> queue = new LinkedList<>();
        int  level = 1;
        queue.offer(start);
        boolean[] mark = new boolean[graphic.length];
        mark[start] = true;
        while(!queue.isEmpty()) {
            int size = queue.size();
            level++;
            while(size-- > 0) {
                int curr = queue.poll();
                for(Integer next : graphic[curr]){
        
                    if(next == end) {
                        return level;
                    }
                    if(mark[next]){
                        continue;
                    }
                    queue.offer(next);
                    mark[next] = true;
                }
            }
        }
        return 0;
    }

}
```

### DFS

遍历得到一个节点，立即对该节点进行遍历

栈：保存当前节点的信息

标记：对遍历过的节点进行标记

一般用于解决可达性问题

------



#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

难度中等376

给定一个包含了一些 `0` 和 `1` 的非空二维数组 `grid` 。

一个 **岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在水平或者竖直方向上相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 `0` 。)

 

**示例 1:**

```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```

对于上面这个给定矩阵应返回 `6`。注意答案不应该是 `11` ，因为岛屿只能包含水平或垂直的四个方向的 `1` 。

**示例 2:**

```
[[0,0,0,0,0,0,0,0]]
```

对于上面这个给定的矩阵, 返回 `0`。



```java
class Solution {
    private int m;
    private int n;
    private int[][] direction = {{0,1},{-1,0},{0,-1},{1,0}};
    public int maxAreaOfIsland(int[][] grid) {
       int maxArea = 0;
       m = grid.length;
       if(m <= 0) {
           return 0;
       }
       n = grid[0].length;
       for (int i = 0; i < m; i++) {
           for (int j = 0; j < n; j++) {
               maxArea = Math.max(maxArea,dfs(i,j,grid));
           }
       }
       return maxArea;
    } 

    public int dfs(int r,int c,int[][] grid){
        if(r < 0 || r >= m || c < 0 || c >= n || grid[r][c] == 0) {
            return 0;
        }
        grid[r][c] = 0;
        int area = 1;
        for(int[] arr : direction) {
            area += dfs(r+arr[0],c+arr[1],grid);
        }
        return area;
    }

}
```

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

难度中等811

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`





```java
class Solution {
    int m;
    int n;
    int[][] direction = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        m = grid.length;
        n = grid[0].length;
        int isLandsNum = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] != '0'){
                    dfs(i,j,grid);
                    isLandsNum++;
                }
               
            }
        }
        return isLandsNum;
    }
    public void dfs(int c, int r, char[][] grid) {
        if (c < 0 || c >= m || r < 0 || r >= n || grid[c][r] == '0'){
            return;
        }
        grid[c][r] = '0'; 
        for (int[] d : direction) {
            dfs(c+d[0], r + d[1], grid);
        }
    }
}
```

#### [547. 朋友圈](https://leetcode-cn.com/problems/friend-circles/)

难度中等350

班上有 **N** 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 **N \* N** 的矩阵 **M**，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生**互为**朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

 

**示例 1：**

```
输入：
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出：2 
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回 2 。
```

**示例 2：**

```
输入：
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出：1
解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。
```

```java
class Solution {

    private int n;
    public int findCircleNum(int[][] M) {
        if(M==null || M.length == 0) {
            return 0;
        }
        n = M.length;
        int num = 0;
        boolean[] visted = new boolean[n];
        for (int i = 0; i < n; i++) {
            if (!visted[i]) {
                dfs(M,visted,i);
                num++;
            }
        }
        return num;
    }

    private void dfs(final int[][] M, boolean[] visited, int i){
        visited[i] = true;
        for (int k = 0; k < n; k++) {
            if(M[i][k] == 1 && !visited[k]) {
                dfs(M,visited,k);
            }
        }
    }
}
```



### 回溯

普通的DFS解决可达性问题，到达特定的点返回即可，而回溯需要继续求解。

------



#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

难度中等961

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

**示例:**

```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

**说明:**
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

通过次数185,432

提交次数334,001



```java
class Solution {

    private String[] KEYS = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs","tuv", "wxyz"};
    public List<String> letterCombinations(String digits) {
        ArrayList<String> combinations = new ArrayList<>();
        if(digits == null || digits.length() == 0) {
            return res;
        }
        
        doCombinaion(new StringBuilder(),combinations,digits);
        return combinations;
    }

    public void doCombinaion(StringBuilder prefix,List<String> combinations,String digits){
        if(prefix.length() == digits.length()) {
            resList.add(prefix.toString());
            return;
        }
        int curDigits = digits.charAt(prefix.length())-'0';
        String letters = KEYS[curDigits];
        for(char c : letters.toCharArray()){
            prefix.append(c);
            doCombinaion(prefix,combinations,digits);
            prefix.deleteCharAt(prefix.length()-1);
        }
        
    }
}
```

#### [93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

难度中等440

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

**有效的 IP 地址** 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 `0`），整数之间用 `'.' `分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 **有效的** IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 **无效的** IP 地址。

 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

**示例 2：**

```
输入：s = "0000"
输出：["0.0.0.0"]
```

**示例 3：**

```
输入：s = "1111"
输出：["1.1.1.1"]
```

**示例 4：**

```
输入：s = "010010"
输出：["0.10.0.10","0.100.1.0"]
```

**示例 5：**

```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

 

**提示：**

- `0 <= s.length <= 3000`
- `s` 仅由数字组成



```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> addresses = new ArrayList<>();
        StringBuilder tempAddress = new StringBuilder();
        doRestore(0,tempAddress,addresses,s);
        return addresses;
    }

    public void doRestore(int k,StringBuilder tempAddress,List<String> addresses,String s) {
        if(k==4 || s.length() ==0){
            if(k==4 && s.length()==0){
                addresses.add(tempAddress.toString());
            }
            return;
        }
        for(int i = 0;i<s.length()&&i<=2;i++){
            if(i!=0&&s.charAt(0)=='0'){
                break;
            }
            if(Integer.valueOf(s.substring(0,i+1))<=255){
                String part  = s.substring(0,i+1);
                if(tempAddress.length()!=0){
                    part = "."+ part;
                }
                doRestore(k+1,tempAddress.append(part),addresses,s.substring(i+1));
                tempAddress.delete(tempAddress.length()-part.length(),tempAddress.length());
            }

        }
    }
}
```

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

难度中等955

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> permutes = new ArrayList<>();
        if(nums==null || nums.length==0){
            return permutes;
        }
        boolean[] visited = new boolean[nums.length];
        List<Integer> permuteList = new ArrayList();
        backtracking(permutes,permuteList,visited,nums);
        return permutes;
    }
    
    public void backtracking(List<List<Integer>> permutes,List<Integer> permuteList,boolean[] visited,
            final int[] nums){
        if(permuteList.size() == nums.length) {
            permutes.add(new ArrayList(permuteList));
            return;
        }

        for (int i = 0; i < visited.length; i++) {
            if(visited[i]) {
                continue;
            }
            permuteList.add(nums[i]);
            visited[i] = true;
            backtracking(permutes,permuteList,visited,nums);
            permuteList.remove(permuteList.size()-1);
            visited[i] = false;
        }
    }
}
```

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

难度中等493

给定一个可包含重复数字的序列，返回所有不重复的全排列。

**示例:**

```
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> permutes = new ArrayList<>();
        List<Integer> permuteList = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return permutes;
        }
        Arrays.sort(nums);
        boolean[] hasVisited = new boolean[nums.length];
        backtracking(permutes,permuteList,hasVisited,nums);
        return permutes;
    }

    public void backtracking(List<List<Integer>> permutes, List<Integer> permuteList, boolean[] visited,
        final int[] nums) {
        if (permuteList.size() == nums.length) {
            permutes.add(new ArrayList(permuteList));
            return;
        }
        for (int i = 0; i < visited.length; i++) {
            if(i > 0 && nums[i] == nums[i-1] && !visited[i-1]) {
                continue;
            }
            if(visited[i]){
                continue;
            }
            visited[i] = true;
            permuteList.add(nums[i]);
            backtracking(permutes,permuteList,visited,nums);
            permuteList.remove(permuteList.size()-1);
            visited[i] = false;

        }
    }
}
```

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

难度中等416

给定两个整数 *n* 和 *k*，返回 1 ... *n* 中所有可能的 *k* 个数的组合。

**示例:**

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> combinations = new ArrayList<>();
        List<Integer> combineList = new ArrayList<>();
        backtracking(combinations,combineList,1,k,n);
        return combinations;
    }

    public void backtracking(List<List<Integer>> combinations, List<Integer> combineList, int start,
        int k, int n) {
        if (k == 0) {
            combinations.add(new ArrayList(combineList));
            return;
        }
        for (int i = start; i <= n - k + 1; i++) {
            combineList.add(i);
            backtracking(combinations,combineList, i + 1, k - 1, n);
            combineList.remove(combineList.size() - 1);
        }
    }
}
```

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

难度中等842

给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）。

**说明：**解集不能包含重复的子集。

**示例:**

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> subsets = new ArrayList<>();
        List<Integer> subsetList = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return subsets;
        }
        for (int size = 0; size <= nums.length; size++) {
            backtracking(subsets,subsetList,0,size,nums);
        }
        return subsets;
    }

    private void backtracking(List<List<Integer>> subsets,List<Integer> subsetList,int start, int size,
        int[] nums) {
        if(subsetList.size() == size) {
            subsets.add(new ArrayList(subsetList));
            return;
        }
        for (int i = start; i < nums.length; i++) {
            subsetList.add(nums[i]);
            backtracking(subsets,subsetList,i+1,size,nums);
            subsetList.remove(subsetList.size()-1);
        }
    }
}
```

#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

难度简单384

给定一个二叉树，返回所有从根节点到叶子节点的路径。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> values = new ArrayList<>();
        List<Integer> paths = new ArrayList<>();
        backtracking(root,values,paths);
        return values;
    }

    private void backtracking(TreeNode node,List<String> values,List<Integer> paths) {
        if(node == null) {
            return;
        }

        if(isLeaf(node)){
            paths.add(node.val);
            values.add(buildPath(paths));
        } else {
            paths.add(node.val);
            backtracking(node.left,values,paths);
            backtracking(node.right,values,paths);
        }
        paths.remove(paths.size()-1);

    }

    private boolean isLeaf(TreeNode node) {
        return node.left == null && node.right == null;
    }

    private String buildPath(List<Integer> paths) {
        StringBuilder str = new StringBuilder();
        for (int i = 0; i < paths.size(); i++) {
            if(i != paths.size() - 1) {
                str.append(paths.get(i)).append("->");
            } else {
                str.append(paths.get(i));
            }
            
        }
        return str.toString();
    } 
}

```

### 字符串

#### [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

难度简单297

给定一个字符串 `s`，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**

```
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```

**示例 2 :**

```
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
```

**注意：**

- `s.length` 在1到50,000之间。
- `s` 只包含“0”或“1”字符。

```java
class Solution {
    public int countBinarySubstrings(String s) {
        int prelen = 0;
        int curlen = 1;
        int count = 0;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                curlen++;
            } else {
                prelen = curlen;
                curlen = 1;
            }

            if (prelen >= curlen) {
                count++;
            }
        }
        return count;
    }
}
```





#### [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

难度简单1275

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**示例 1:**

```
输入: 121
输出: true
```

**示例 2:**

```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3:**

```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```

```java
class Solution {
    public boolean isPalindrome(int x) {
        if (x == 0) {
        	return true;
        }
        if (x < 0 || x % 10 == 0){ 
            return false;
        }
        int right = 0;
        while (x > right) {
            right = right * 10 + x % 10;
            x /= 10;
        }
        return x == right || x == right / 10;
    }
}
```

