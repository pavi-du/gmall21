### 动态规划

#### 概念

*名词*

多阶段：将一个问题划分为多个阶段；
状态：每个阶段的出发点为状态；
决策：每个阶段做出的选择就是决策，
策略：各个阶段的决策变量组成的序列时策略；
最优策略：从策略中找到最优效果的策略；
状态转移方程：前一阶段的终点到后一阶段的起点；



*无后效性*

最优子结构：子问题的最优解会导致全局最优；
无后效性：某个阶段状态选择只和它的前一阶段有关。



#### 斐波那契数列问题

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

难度简单1292

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

##### code

```java
class Solution {
    public int climbStairs(int n) {

        if (n <= 1) {
            return n;
        }
        int[] dp = new int[n];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < n; i++) {
            dp[i] = dp[i-1] + dp[i - 2];
        }
        return dp[n - 1];
    }
}
```

改进



```java
class Solution {
    public int climbStairs(int n) {

        if (n <= 1) {
            return n;
        }
        
        int pre2 = 1;
        int pre1 = 2;
        for (int i = 2; i < n; i++) {
            int cur = pre2 + pre1;
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
}
```

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

难度简单1123

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

 

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

##### code

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-2] + nums[i], dp[i - 1]);
        }
        return dp[nums.length-1];
    }
}
```

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        int[] dp = new int[nums.length];
        
        int pre2 = nums[0];
        int pre1 = Math.max(nums[0], nums[1]);
        for (int i = 2; i < nums.length; i++) {
            int cur = Math.max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
}
```

#### 矩阵路径



### BFS

一层一层的遍历，每层遍历以上一层遍历的结果作为起点，遍历一个距离所能到达的所有节点

队列：用来存储每一轮遍历的结果；

标记：对于遍历过的节点应该做标记，防止重复遍历

一般用来解决最短路径，di<=dj

------



####  最短路径

计算网格中起点到网格中任意一点的最短路径

```
[[1,1,0,1],
[1,0,1,0],
[1,1,1,1],
[1,0,1,1]]
```

```java
public int minPathLength(int[][] grids, int tr, int tc) {
    final int[][] direction = {{0,1}, {1,0}, {0,-1}, {-1,0}};
    int m = grids.length;
    int n = grids[0].length;
    Queue<Pair<Integer,Integer>> queue = new LinkedList<>();
    int pathLenth = 0;
    queue.offer(new Pair(grids[0][0]));
    grids[0][0] =1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        pathLenth++;
        while (size-- > 0) {
            Pair<Integer,Integer> cur = queue.poll();
            int cr = cur.getKey();
            int cc = cur.getValue();
            for (int[] d : direction) {
                int nr = cr + d[0];
                int nc = cc + d[1];
                if (nr < 0 || nr >= m || nc < 0 || nc >= n || grids[nr][nc] == 0)					{
                    continue;
                }
                if (nr ==  tr && nc == tc) {
                    return pathLenth;
                }
                grids[nr][nc] = 0;
                queue.offer(new Pair<Integer>(nr,nc));
            }
        }
    }
    return -1;
    
}
```



####  [279完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/perfect-squares
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



```java
class Solution {
    public int numSquares(int n) {
       
        int level  = 0;
        boolean[] mark = new boolean[n+1];
        List<Integer> squares = generateSquares(n);
        // LinkedList:offer poll
        LinkedList<Integer> queue = new LinkedList<>();
        queue.offer(n);

        while (!queue.isEmpty()) {
            int size = queue.size();
            level++;
            while (size-- > 0) {
                int curr = queue.poll();
                for (int s : squares) {
                    int next = curr - s;
                    if(next < 0) {
                        break;
                    }
                    if(next == 0) {
                        return level;
                    }
                    // 先访问过一定比 后访问使用的路径少
                    if(mark[next]){
                        continue;
                    }
                    queue.offer(next);
                    mark[next] = true;
                }
            }
        } 
        return 0;
    }

    public List<Integer> generateSquares(int n) {
        List<Integer> squares = new ArrayList<>();
        int square = 1;
        int diff = 3;
        while (square <= n) {
            squares.add(square);
            square += diff;
            diff += 2;
        }
        return squares;
    }
}
```

#### [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

难度中等473

给定两个单词（*beginWord* 和 *endWord*）和一个字典，找到从 *beginWord* 到 *endWord* 的最短转换序列的长度。转换需遵循如下规则：

1. 每次转换只能改变一个字母。
2. 转换过程中的中间单词必须是字典中的单词。

**说明:**

- 如果不存在这样的转换序列，返回 0。
- 所有单词具有相同的长度。
- 所有单词只由小写字母组成。
- 字典中不存在重复的单词。
- 你可以假设 *beginWord* 和 *endWord* 是非空的，且二者不相同。

**示例 1:**

```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。
```

**示例 2:**

```
输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

输出: 0

解释: endWord "cog" 不在字典中，所以无法进行转换。
```

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        wordList.add(beginWord);
        int size = wordList.size();
        int start = size - 1;
        int end = 0;
        while (end < size && !endWord.equals(wordList.get(end))) {
           end++;
        }
        if(end == size) {
            return 0;
        }
        List<Integer>[] graphic = buildGraphic(wordList);
        return getShortestPath(start,end,graphic);
    }
    public List<Integer>[] buildGraphic(List<String> wordList) {
         if(wordList == null) {
            return null;
        }
        int size = wordList.size();
        List<Integer>[] graphic = new ArrayList[size];
       
        for (int i = 0; i < size; i++) {
            graphic[i] = new ArrayList<Integer>();
             for (int j = 0; j < size; j++) {
                 if(isConnect(wordList.get(i),wordList.get(j))){
                     graphic[i].add(j);
                 }
            }
        }
        return graphic;
    }


    // 判断俩个字符串是否差一个字符
    public boolean isConnect(String str1,String str2){
        int diff = 0;
        int length = str1.length();
        for (int i = 0; i < length && diff <= 1; i++) {
            if(str1.charAt(i)!=str2.charAt(i)){
                diff++;
            }
        }
        return diff == 1;
    }

    public int getShortestPath(int start,int end,List<Integer>[] graphic) {
        LinkedList<Integer> queue = new LinkedList<>();
        int  level = 1;
        queue.offer(start);
        boolean[] mark = new boolean[graphic.length];
        mark[start] = true;
        while(!queue.isEmpty()) {
            int size = queue.size();
            level++;
            while(size-- > 0) {
                int curr = queue.poll();
                for(Integer next : graphic[curr]){
        
                    if(next == end) {
                        return level;
                    }
                    if(mark[next]){
                        continue;
                    }
                    queue.offer(next);
                    mark[next] = true;
                }
            }
        }
        return 0;
    }

}
```

### DFS

遍历得到一个节点，立即对该节点进行遍历

栈：保存当前节点的信息

标记：对遍历过的节点进行标记

一般用于解决可达性问题

------



#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

难度中等376

给定一个包含了一些 `0` 和 `1` 的非空二维数组 `grid` 。

一个 **岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在水平或者竖直方向上相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 `0` 。)

 

**示例 1:**

```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```

对于上面这个给定矩阵应返回 `6`。注意答案不应该是 `11` ，因为岛屿只能包含水平或垂直的四个方向的 `1` 。

**示例 2:**

```
[[0,0,0,0,0,0,0,0]]
```

对于上面这个给定的矩阵, 返回 `0`。



```java
class Solution {
    private int m;
    private int n;
    private int[][] direction = {{0,1},{-1,0},{0,-1},{1,0}};
    public int maxAreaOfIsland(int[][] grid) {
       int maxArea = 0;
       m = grid.length;
       if(m <= 0) {
           return 0;
       }
       n = grid[0].length;
       for (int i = 0; i < m; i++) {
           for (int j = 0; j < n; j++) {
               maxArea = Math.max(maxArea,dfs(i,j,grid));
           }
       }
       return maxArea;
    } 

    public int dfs(int r,int c,int[][] grid){
        if(r < 0 || r >= m || c < 0 || c >= n || grid[r][c] == 0) {
            return 0;
        }
        grid[r][c] = 0;
        int area = 1;
        for(int[] arr : direction) {
            area += dfs(r+arr[0],c+arr[1],grid);
        }
        return area;
    }

}
```

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

难度中等811

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`





```java
class Solution {
    int m;
    int n;
    int[][] direction = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        m = grid.length;
        n = grid[0].length;
        int isLandsNum = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] != '0'){
                    dfs(i,j,grid);
                    isLandsNum++;
                }
               
            }
        }
        return isLandsNum;
    }
    public void dfs(int c, int r, char[][] grid) {
        if (c < 0 || c >= m || r < 0 || r >= n || grid[c][r] == '0'){
            return;
        }
        grid[c][r] = '0'; 
        for (int[] d : direction) {
            dfs(c+d[0], r + d[1], grid);
        }
    }
}
```

#### [547. 朋友圈](https://leetcode-cn.com/problems/friend-circles/)

难度中等350

班上有 **N** 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 **N \* N** 的矩阵 **M**，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生**互为**朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

 

**示例 1：**

```
输入：
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出：2 
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回 2 。
```

**示例 2：**

```
输入：
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出：1
解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。
```

```java
class Solution {

    private int n;
    public int findCircleNum(int[][] M) {
        if(M==null || M.length == 0) {
            return 0;
        }
        n = M.length;
        int num = 0;
        boolean[] visted = new boolean[n];
        for (int i = 0; i < n; i++) {
            if (!visted[i]) {
                dfs(M,visted,i);
                num++;
            }
        }
        return num;
    }

    private void dfs(final int[][] M, boolean[] visited, int i){
        visited[i] = true;
        for (int k = 0; k < n; k++) {
            if(M[i][k] == 1 && !visited[k]) {
                dfs(M,visited,k);
            }
        }
    }
}
```



### 回溯

普通的DFS解决可达性问题，到达特定的点返回即可，而回溯需要继续求解。

------



#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

难度中等961

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

**示例:**

```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

**说明:**
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

通过次数185,432

提交次数334,001



```java
class Solution {

    private String[] KEYS = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs","tuv", "wxyz"};
    public List<String> letterCombinations(String digits) {
        ArrayList<String> combinations = new ArrayList<>();
        if(digits == null || digits.length() == 0) {
            return res;
        }
        
        doCombinaion(new StringBuilder(),combinations,digits);
        return combinations;
    }

    public void doCombinaion(StringBuilder prefix,List<String> combinations,String digits){
        if(prefix.length() == digits.length()) {
            resList.add(prefix.toString());
            return;
        }
        int curDigits = digits.charAt(prefix.length())-'0';
        String letters = KEYS[curDigits];
        for(char c : letters.toCharArray()){
            prefix.append(c);
            doCombinaion(prefix,combinations,digits);
            prefix.deleteCharAt(prefix.length()-1);
        }
        
    }
}
```

#### [93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

难度中等440

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

**有效的 IP 地址** 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 `0`），整数之间用 `'.' `分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 **有效的** IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 **无效的** IP 地址。

 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

**示例 2：**

```
输入：s = "0000"
输出：["0.0.0.0"]
```

**示例 3：**

```
输入：s = "1111"
输出：["1.1.1.1"]
```

**示例 4：**

```
输入：s = "010010"
输出：["0.10.0.10","0.100.1.0"]
```

**示例 5：**

```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

 

**提示：**

- `0 <= s.length <= 3000`
- `s` 仅由数字组成



```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> addresses = new ArrayList<>();
        StringBuilder tempAddress = new StringBuilder();
        doRestore(0,tempAddress,addresses,s);
        return addresses;
    }

    public void doRestore(int k,StringBuilder tempAddress,List<String> addresses,String s) {
        if(k==4 || s.length() ==0){
            if(k==4 && s.length()==0){
                addresses.add(tempAddress.toString());
            }
            return;
        }
        for(int i = 0;i<s.length()&&i<=2;i++){
            if(i!=0&&s.charAt(0)=='0'){
                break;
            }
            if(Integer.valueOf(s.substring(0,i+1))<=255){
                String part  = s.substring(0,i+1);
                if(tempAddress.length()!=0){
                    part = "."+ part;
                }
                doRestore(k+1,tempAddress.append(part),addresses,s.substring(i+1));
                tempAddress.delete(tempAddress.length()-part.length(),tempAddress.length());
            }

        }
    }
}
```

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

难度中等955

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> permutes = new ArrayList<>();
        if(nums==null || nums.length==0){
            return permutes;
        }
        boolean[] visited = new boolean[nums.length];
        List<Integer> permuteList = new ArrayList();
        backtracking(permutes,permuteList,visited,nums);
        return permutes;
    }
    
    public void backtracking(List<List<Integer>> permutes,List<Integer> permuteList,boolean[] visited,
            final int[] nums){
        if(permuteList.size() == nums.length) {
            permutes.add(new ArrayList(permuteList));
            return;
        }

        for (int i = 0; i < visited.length; i++) {
            if(visited[i]) {
                continue;
            }
            permuteList.add(nums[i]);
            visited[i] = true;
            backtracking(permutes,permuteList,visited,nums);
            permuteList.remove(permuteList.size()-1);
            visited[i] = false;
        }
    }
}
```

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

难度中等493

给定一个可包含重复数字的序列，返回所有不重复的全排列。

**示例:**

```
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> permutes = new ArrayList<>();
        List<Integer> permuteList = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return permutes;
        }
        Arrays.sort(nums);
        boolean[] hasVisited = new boolean[nums.length];
        backtracking(permutes,permuteList,hasVisited,nums);
        return permutes;
    }

    public void backtracking(List<List<Integer>> permutes, List<Integer> permuteList, boolean[] visited,
        final int[] nums) {
        if (permuteList.size() == nums.length) {
            permutes.add(new ArrayList(permuteList));
            return;
        }
        for (int i = 0; i < visited.length; i++) {
            if(i > 0 && nums[i] == nums[i-1] && !visited[i-1]) {
                continue;
            }
            if(visited[i]){
                continue;
            }
            visited[i] = true;
            permuteList.add(nums[i]);
            backtracking(permutes,permuteList,visited,nums);
            permuteList.remove(permuteList.size()-1);
            visited[i] = false;

        }
    }
}
```

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

难度中等416

给定两个整数 *n* 和 *k*，返回 1 ... *n* 中所有可能的 *k* 个数的组合。

**示例:**

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> combinations = new ArrayList<>();
        List<Integer> combineList = new ArrayList<>();
        backtracking(combinations,combineList,1,k,n);
        return combinations;
    }

    public void backtracking(List<List<Integer>> combinations, List<Integer> combineList, int start,
        int k, int n) {
        if (k == 0) {
            combinations.add(new ArrayList(combineList));
            return;
        }
        for (int i = start; i <= n - k + 1; i++) {
            combineList.add(i);
            backtracking(combinations,combineList, i + 1, k - 1, n);
            combineList.remove(combineList.size() - 1);
        }
    }
}
```

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

难度中等842

给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）。

**说明：**解集不能包含重复的子集。

**示例:**

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> subsets = new ArrayList<>();
        List<Integer> subsetList = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return subsets;
        }
        for (int size = 0; size <= nums.length; size++) {
            backtracking(subsets,subsetList,0,size,nums);
        }
        return subsets;
    }

    private void backtracking(List<List<Integer>> subsets,List<Integer> subsetList,int start, int size,
        int[] nums) {
        if(subsetList.size() == size) {
            subsets.add(new ArrayList(subsetList));
            return;
        }
        for (int i = start; i < nums.length; i++) {
            subsetList.add(nums[i]);
            backtracking(subsets,subsetList,i+1,size,nums);
            subsetList.remove(subsetList.size()-1);
        }
    }
}
```

#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

难度简单384

给定一个二叉树，返回所有从根节点到叶子节点的路径。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> values = new ArrayList<>();
        List<Integer> paths = new ArrayList<>();
        backtracking(root,values,paths);
        return values;
    }

    private void backtracking(TreeNode node,List<String> values,List<Integer> paths) {
        if(node == null) {
            return;
        }

        if(isLeaf(node)){
            paths.add(node.val);
            values.add(buildPath(paths));
        } else {
            paths.add(node.val);
            backtracking(node.left,values,paths);
            backtracking(node.right,values,paths);
        }
        paths.remove(paths.size()-1);

    }

    private boolean isLeaf(TreeNode node) {
        return node.left == null && node.right == null;
    }

    private String buildPath(List<Integer> paths) {
        StringBuilder str = new StringBuilder();
        for (int i = 0; i < paths.size(); i++) {
            if(i != paths.size() - 1) {
                str.append(paths.get(i)).append("->");
            } else {
                str.append(paths.get(i));
            }
            
        }
        return str.toString();
    } 
}

```

### 字符串

#### [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

难度简单297

给定一个字符串 `s`，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**

```
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```

**示例 2 :**

```
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
```

**注意：**

- `s.length` 在1到50,000之间。
- `s` 只包含“0”或“1”字符。

```java
class Solution {
    public int countBinarySubstrings(String s) {
        int prelen = 0;
        int curlen = 1;
        int count = 0;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                curlen++;
            } else {
                prelen = curlen;
                curlen = 1;
            }

            if (prelen >= curlen) {
                count++;
            }
        }
        return count;
    }
}
```





#### [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

难度简单1275

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**示例 1:**

```
输入: 121
输出: true
```

**示例 2:**

```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3:**

```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```

```java
class Solution {
    public boolean isPalindrome(int x) {
        if (x == 0) {
        	return true;
        }
        if (x < 0 || x % 10 == 0){ 
            return false;
        }
        int right = 0;
        while (x > right) {
            right = right * 10 + x % 10;
            x /= 10;
        }
        return x == right || x == right / 10;
    }
}
```

